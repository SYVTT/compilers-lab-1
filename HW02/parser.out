Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> declarations fundefs_opt instructions_opt
Rule 2     declarations -> declarations declaration
Rule 3     declarations -> <empty>
Rule 4     declaration -> TYPE inits ;
Rule 5     declaration -> error ;
Rule 6     inits -> inits , init
Rule 7     inits -> init
Rule 8     init -> ID = expression
Rule 9     instructions_opt -> instructions
Rule 10    instructions_opt -> <empty>
Rule 11    instructions -> instructions instruction
Rule 12    instructions -> instruction
Rule 13    instruction -> print_instr
Rule 14    instruction -> labeled_instr
Rule 15    instruction -> assignment
Rule 16    instruction -> choice_instr
Rule 17    instruction -> while_instr
Rule 18    instruction -> repeat_instr
Rule 19    instruction -> return_instr
Rule 20    instruction -> break_instr
Rule 21    instruction -> continue_instr
Rule 22    instruction -> compound_instr
Rule 23    instruction -> expression ;
Rule 24    print_instr -> PRINT expr_list ;
Rule 25    print_instr -> PRINT error ;
Rule 26    labeled_instr -> ID : instruction
Rule 27    assignment -> ID = expression ;
Rule 28    choice_instr -> IF ( condition ) instruction
Rule 29    choice_instr -> IF ( condition ) instruction ELSE instruction
Rule 30    choice_instr -> IF ( error ) instruction
Rule 31    choice_instr -> IF ( error ) instruction ELSE instruction
Rule 32    while_instr -> WHILE ( condition ) instruction
Rule 33    while_instr -> WHILE ( error ) instruction
Rule 34    repeat_instr -> REPEAT instructions UNTIL condition ;
Rule 35    return_instr -> RETURN expression ;
Rule 36    continue_instr -> CONTINUE ;
Rule 37    break_instr -> BREAK ;
Rule 38    compound_instr -> { declarations instructions_opt }
Rule 39    condition -> expression
Rule 40    const -> INTEGER
Rule 41    const -> FLOAT
Rule 42    const -> STRING
Rule 43    expression -> const
Rule 44    expression -> ID
Rule 45    expression -> bin_expression
Rule 46    expression -> ( expression )
Rule 47    expression -> ( error )
Rule 48    expression -> ID ( expr_list_or_empty )
Rule 49    expression -> ID ( error )
Rule 50    bin_expression -> expression + expression
Rule 51    bin_expression -> expression - expression
Rule 52    bin_expression -> expression * expression
Rule 53    bin_expression -> expression / expression
Rule 54    bin_expression -> expression % expression
Rule 55    bin_expression -> expression | expression
Rule 56    bin_expression -> expression & expression
Rule 57    bin_expression -> expression ^ expression
Rule 58    bin_expression -> expression AND expression
Rule 59    bin_expression -> expression OR expression
Rule 60    bin_expression -> expression SHL expression
Rule 61    bin_expression -> expression SHR expression
Rule 62    bin_expression -> expression EQ expression
Rule 63    bin_expression -> expression NEQ expression
Rule 64    bin_expression -> expression > expression
Rule 65    bin_expression -> expression < expression
Rule 66    bin_expression -> expression LE expression
Rule 67    bin_expression -> expression GE expression
Rule 68    expr_list_or_empty -> expr_list
Rule 69    expr_list_or_empty -> <empty>
Rule 70    expr_list -> expr_list , expression
Rule 71    expr_list -> expression
Rule 72    fundefs_opt -> fundefs
Rule 73    fundefs_opt -> <empty>
Rule 74    fundefs -> fundefs fundef
Rule 75    fundefs -> fundef
Rule 76    fundef -> TYPE ID ( args_list_or_empty ) compound_instr
Rule 77    args_list_or_empty -> args_list
Rule 78    args_list_or_empty -> <empty>
Rule 79    args_list -> args_list , arg
Rule 80    args_list -> arg
Rule 81    arg -> TYPE ID

Terminals, with rules where they appear

%                    : 54
&                    : 56
(                    : 28 29 30 31 32 33 46 47 48 49 76
)                    : 28 29 30 31 32 33 46 47 48 49 76
*                    : 52
+                    : 50
,                    : 6 70 79
-                    : 51
/                    : 53
:                    : 26
;                    : 4 5 23 24 25 27 34 35 36 37
<                    : 65
=                    : 8 27
>                    : 64
AND                  : 58
BREAK                : 37
CONTINUE             : 36
ELSE                 : 29 31
EQ                   : 62
FLOAT                : 41
GE                   : 67
ID                   : 8 26 27 44 48 49 76 81
IF                   : 28 29 30 31
INTEGER              : 40
LE                   : 66
NEQ                  : 63
OR                   : 59
PRINT                : 24 25
REPEAT               : 34
RETURN               : 35
SHL                  : 60
SHR                  : 61
STRING               : 42
TYPE                 : 4 76 81
UNTIL                : 34
WHILE                : 32 33
^                    : 57
error                : 5 25 30 31 33 47 49
{                    : 38
|                    : 55
}                    : 38

Nonterminals, with rules where they appear

arg                  : 79 80
args_list            : 77 79
args_list_or_empty   : 76
assignment           : 15
bin_expression       : 45
break_instr          : 20
choice_instr         : 16
compound_instr       : 22 76
condition            : 28 29 32 34
const                : 43
continue_instr       : 21
declaration          : 2
declarations         : 1 2 38
expr_list            : 24 68 70
expr_list_or_empty   : 48
expression           : 8 23 27 35 39 46 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 66 67 67 70 71
fundef               : 74 75
fundefs              : 72 74
fundefs_opt          : 1
init                 : 6 7
inits                : 4 6
instruction          : 11 12 26 28 29 29 30 31 31 32 33
instructions         : 9 11 34
instructions_opt     : 1 38
labeled_instr        : 14
print_instr          : 13
program              : 0
repeat_instr         : 18
return_instr         : 19
while_instr          : 17

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declarations fundefs_opt instructions_opt
    (2) declarations -> . declarations declaration
    (3) declarations -> .

    TYPE            reduce using rule 3 (declarations -> .)
    error           reduce using rule 3 (declarations -> .)
    PRINT           reduce using rule 3 (declarations -> .)
    ID              reduce using rule 3 (declarations -> .)
    IF              reduce using rule 3 (declarations -> .)
    WHILE           reduce using rule 3 (declarations -> .)
    REPEAT          reduce using rule 3 (declarations -> .)
    RETURN          reduce using rule 3 (declarations -> .)
    BREAK           reduce using rule 3 (declarations -> .)
    CONTINUE        reduce using rule 3 (declarations -> .)
    {               reduce using rule 3 (declarations -> .)
    (               reduce using rule 3 (declarations -> .)
    INTEGER         reduce using rule 3 (declarations -> .)
    FLOAT           reduce using rule 3 (declarations -> .)
    STRING          reduce using rule 3 (declarations -> .)
    $end            reduce using rule 3 (declarations -> .)

    program                        shift and go to state 1
    declarations                   shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> declarations . fundefs_opt instructions_opt
    (2) declarations -> declarations . declaration
    (72) fundefs_opt -> . fundefs
    (73) fundefs_opt -> .
    (4) declaration -> . TYPE inits ;
    (5) declaration -> . error ;
    (74) fundefs -> . fundefs fundef
    (75) fundefs -> . fundef
    (76) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

    PRINT           reduce using rule 73 (fundefs_opt -> .)
    ID              reduce using rule 73 (fundefs_opt -> .)
    IF              reduce using rule 73 (fundefs_opt -> .)
    WHILE           reduce using rule 73 (fundefs_opt -> .)
    REPEAT          reduce using rule 73 (fundefs_opt -> .)
    RETURN          reduce using rule 73 (fundefs_opt -> .)
    BREAK           reduce using rule 73 (fundefs_opt -> .)
    CONTINUE        reduce using rule 73 (fundefs_opt -> .)
    {               reduce using rule 73 (fundefs_opt -> .)
    (               reduce using rule 73 (fundefs_opt -> .)
    INTEGER         reduce using rule 73 (fundefs_opt -> .)
    FLOAT           reduce using rule 73 (fundefs_opt -> .)
    STRING          reduce using rule 73 (fundefs_opt -> .)
    $end            reduce using rule 73 (fundefs_opt -> .)
    TYPE            shift and go to state 8
    error           shift and go to state 3

    fundefs                        shift and go to state 4
    fundef                         shift and go to state 5
    fundefs_opt                    shift and go to state 6
    declaration                    shift and go to state 7

state 3

    (5) declaration -> error . ;

    ;               shift and go to state 9


state 4

    (72) fundefs_opt -> fundefs .
    (74) fundefs -> fundefs . fundef
    (76) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

    PRINT           reduce using rule 72 (fundefs_opt -> fundefs .)
    ID              reduce using rule 72 (fundefs_opt -> fundefs .)
    IF              reduce using rule 72 (fundefs_opt -> fundefs .)
    WHILE           reduce using rule 72 (fundefs_opt -> fundefs .)
    REPEAT          reduce using rule 72 (fundefs_opt -> fundefs .)
    RETURN          reduce using rule 72 (fundefs_opt -> fundefs .)
    BREAK           reduce using rule 72 (fundefs_opt -> fundefs .)
    CONTINUE        reduce using rule 72 (fundefs_opt -> fundefs .)
    {               reduce using rule 72 (fundefs_opt -> fundefs .)
    (               reduce using rule 72 (fundefs_opt -> fundefs .)
    INTEGER         reduce using rule 72 (fundefs_opt -> fundefs .)
    FLOAT           reduce using rule 72 (fundefs_opt -> fundefs .)
    STRING          reduce using rule 72 (fundefs_opt -> fundefs .)
    $end            reduce using rule 72 (fundefs_opt -> fundefs .)
    TYPE            shift and go to state 11

    fundef                         shift and go to state 10

state 5

    (75) fundefs -> fundef .

    TYPE            reduce using rule 75 (fundefs -> fundef .)
    PRINT           reduce using rule 75 (fundefs -> fundef .)
    ID              reduce using rule 75 (fundefs -> fundef .)
    IF              reduce using rule 75 (fundefs -> fundef .)
    WHILE           reduce using rule 75 (fundefs -> fundef .)
    REPEAT          reduce using rule 75 (fundefs -> fundef .)
    RETURN          reduce using rule 75 (fundefs -> fundef .)
    BREAK           reduce using rule 75 (fundefs -> fundef .)
    CONTINUE        reduce using rule 75 (fundefs -> fundef .)
    {               reduce using rule 75 (fundefs -> fundef .)
    (               reduce using rule 75 (fundefs -> fundef .)
    INTEGER         reduce using rule 75 (fundefs -> fundef .)
    FLOAT           reduce using rule 75 (fundefs -> fundef .)
    STRING          reduce using rule 75 (fundefs -> fundef .)
    $end            reduce using rule 75 (fundefs -> fundef .)


state 6

    (1) program -> declarations fundefs_opt . instructions_opt
    (9) instructions_opt -> . instructions
    (10) instructions_opt -> .
    (11) instructions -> . instructions instruction
    (12) instructions -> . instruction
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expr_list ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { declarations instructions_opt }
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    $end            reduce using rule 10 (instructions_opt -> .)
    PRINT           shift and go to state 15
    ID              shift and go to state 31
    IF              shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 25
    RETURN          shift and go to state 12
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 38
    {               shift and go to state 39
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    return_instr                   shift and go to state 18
    instruction                    shift and go to state 34
    const                          shift and go to state 19
    print_instr                    shift and go to state 37
    assignment                     shift and go to state 27
    compound_instr                 shift and go to state 30
    choice_instr                   shift and go to state 13
    continue_instr                 shift and go to state 21
    labeled_instr                  shift and go to state 28
    instructions_opt               shift and go to state 29
    bin_expression                 shift and go to state 23
    break_instr                    shift and go to state 33
    while_instr                    shift and go to state 22
    expression                     shift and go to state 40
    repeat_instr                   shift and go to state 17
    instructions                   shift and go to state 32

state 7

    (2) declarations -> declarations declaration .

    TYPE            reduce using rule 2 (declarations -> declarations declaration .)
    error           reduce using rule 2 (declarations -> declarations declaration .)
    PRINT           reduce using rule 2 (declarations -> declarations declaration .)
    ID              reduce using rule 2 (declarations -> declarations declaration .)
    IF              reduce using rule 2 (declarations -> declarations declaration .)
    WHILE           reduce using rule 2 (declarations -> declarations declaration .)
    REPEAT          reduce using rule 2 (declarations -> declarations declaration .)
    RETURN          reduce using rule 2 (declarations -> declarations declaration .)
    BREAK           reduce using rule 2 (declarations -> declarations declaration .)
    CONTINUE        reduce using rule 2 (declarations -> declarations declaration .)
    {               reduce using rule 2 (declarations -> declarations declaration .)
    (               reduce using rule 2 (declarations -> declarations declaration .)
    INTEGER         reduce using rule 2 (declarations -> declarations declaration .)
    FLOAT           reduce using rule 2 (declarations -> declarations declaration .)
    STRING          reduce using rule 2 (declarations -> declarations declaration .)
    $end            reduce using rule 2 (declarations -> declarations declaration .)
    }               reduce using rule 2 (declarations -> declarations declaration .)


state 8

    (4) declaration -> TYPE . inits ;
    (76) fundef -> TYPE . ID ( args_list_or_empty ) compound_instr
    (6) inits -> . inits , init
    (7) inits -> . init
    (8) init -> . ID = expression

    ID              shift and go to state 43

    init                           shift and go to state 41
    inits                          shift and go to state 42

state 9

    (5) declaration -> error ; .

    TYPE            reduce using rule 5 (declaration -> error ; .)
    error           reduce using rule 5 (declaration -> error ; .)
    PRINT           reduce using rule 5 (declaration -> error ; .)
    ID              reduce using rule 5 (declaration -> error ; .)
    IF              reduce using rule 5 (declaration -> error ; .)
    WHILE           reduce using rule 5 (declaration -> error ; .)
    REPEAT          reduce using rule 5 (declaration -> error ; .)
    RETURN          reduce using rule 5 (declaration -> error ; .)
    BREAK           reduce using rule 5 (declaration -> error ; .)
    CONTINUE        reduce using rule 5 (declaration -> error ; .)
    {               reduce using rule 5 (declaration -> error ; .)
    (               reduce using rule 5 (declaration -> error ; .)
    INTEGER         reduce using rule 5 (declaration -> error ; .)
    FLOAT           reduce using rule 5 (declaration -> error ; .)
    STRING          reduce using rule 5 (declaration -> error ; .)
    $end            reduce using rule 5 (declaration -> error ; .)
    }               reduce using rule 5 (declaration -> error ; .)


state 10

    (74) fundefs -> fundefs fundef .

    TYPE            reduce using rule 74 (fundefs -> fundefs fundef .)
    PRINT           reduce using rule 74 (fundefs -> fundefs fundef .)
    ID              reduce using rule 74 (fundefs -> fundefs fundef .)
    IF              reduce using rule 74 (fundefs -> fundefs fundef .)
    WHILE           reduce using rule 74 (fundefs -> fundefs fundef .)
    REPEAT          reduce using rule 74 (fundefs -> fundefs fundef .)
    RETURN          reduce using rule 74 (fundefs -> fundefs fundef .)
    BREAK           reduce using rule 74 (fundefs -> fundefs fundef .)
    CONTINUE        reduce using rule 74 (fundefs -> fundefs fundef .)
    {               reduce using rule 74 (fundefs -> fundefs fundef .)
    (               reduce using rule 74 (fundefs -> fundefs fundef .)
    INTEGER         reduce using rule 74 (fundefs -> fundefs fundef .)
    FLOAT           reduce using rule 74 (fundefs -> fundefs fundef .)
    STRING          reduce using rule 74 (fundefs -> fundefs fundef .)
    $end            reduce using rule 74 (fundefs -> fundefs fundef .)


state 11

    (76) fundef -> TYPE . ID ( args_list_or_empty ) compound_instr

    ID              shift and go to state 44


state 12

    (35) return_instr -> RETURN . expression ;
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 46
    bin_expression                 shift and go to state 23

state 13

    (16) instruction -> choice_instr .

    PRINT           reduce using rule 16 (instruction -> choice_instr .)
    ID              reduce using rule 16 (instruction -> choice_instr .)
    IF              reduce using rule 16 (instruction -> choice_instr .)
    WHILE           reduce using rule 16 (instruction -> choice_instr .)
    REPEAT          reduce using rule 16 (instruction -> choice_instr .)
    RETURN          reduce using rule 16 (instruction -> choice_instr .)
    BREAK           reduce using rule 16 (instruction -> choice_instr .)
    CONTINUE        reduce using rule 16 (instruction -> choice_instr .)
    {               reduce using rule 16 (instruction -> choice_instr .)
    (               reduce using rule 16 (instruction -> choice_instr .)
    INTEGER         reduce using rule 16 (instruction -> choice_instr .)
    FLOAT           reduce using rule 16 (instruction -> choice_instr .)
    STRING          reduce using rule 16 (instruction -> choice_instr .)
    $end            reduce using rule 16 (instruction -> choice_instr .)
    UNTIL           reduce using rule 16 (instruction -> choice_instr .)
    }               reduce using rule 16 (instruction -> choice_instr .)
    ELSE            reduce using rule 16 (instruction -> choice_instr .)


state 14

    (28) choice_instr -> IF . ( condition ) instruction
    (29) choice_instr -> IF . ( condition ) instruction ELSE instruction
    (30) choice_instr -> IF . ( error ) instruction
    (31) choice_instr -> IF . ( error ) instruction ELSE instruction

    (               shift and go to state 47


state 15

    (24) print_instr -> PRINT . expr_list ;
    (25) print_instr -> PRINT . error ;
    (70) expr_list -> . expr_list , expression
    (71) expr_list -> . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    error           shift and go to state 49
    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    expr_list                      shift and go to state 48
    expression                     shift and go to state 50
    bin_expression                 shift and go to state 23
    const                          shift and go to state 19

state 16

    (32) while_instr -> WHILE . ( condition ) instruction
    (33) while_instr -> WHILE . ( error ) instruction

    (               shift and go to state 51


state 17

    (18) instruction -> repeat_instr .

    PRINT           reduce using rule 18 (instruction -> repeat_instr .)
    ID              reduce using rule 18 (instruction -> repeat_instr .)
    IF              reduce using rule 18 (instruction -> repeat_instr .)
    WHILE           reduce using rule 18 (instruction -> repeat_instr .)
    REPEAT          reduce using rule 18 (instruction -> repeat_instr .)
    RETURN          reduce using rule 18 (instruction -> repeat_instr .)
    BREAK           reduce using rule 18 (instruction -> repeat_instr .)
    CONTINUE        reduce using rule 18 (instruction -> repeat_instr .)
    {               reduce using rule 18 (instruction -> repeat_instr .)
    (               reduce using rule 18 (instruction -> repeat_instr .)
    INTEGER         reduce using rule 18 (instruction -> repeat_instr .)
    FLOAT           reduce using rule 18 (instruction -> repeat_instr .)
    STRING          reduce using rule 18 (instruction -> repeat_instr .)
    $end            reduce using rule 18 (instruction -> repeat_instr .)
    UNTIL           reduce using rule 18 (instruction -> repeat_instr .)
    }               reduce using rule 18 (instruction -> repeat_instr .)
    ELSE            reduce using rule 18 (instruction -> repeat_instr .)


state 18

    (19) instruction -> return_instr .

    PRINT           reduce using rule 19 (instruction -> return_instr .)
    ID              reduce using rule 19 (instruction -> return_instr .)
    IF              reduce using rule 19 (instruction -> return_instr .)
    WHILE           reduce using rule 19 (instruction -> return_instr .)
    REPEAT          reduce using rule 19 (instruction -> return_instr .)
    RETURN          reduce using rule 19 (instruction -> return_instr .)
    BREAK           reduce using rule 19 (instruction -> return_instr .)
    CONTINUE        reduce using rule 19 (instruction -> return_instr .)
    {               reduce using rule 19 (instruction -> return_instr .)
    (               reduce using rule 19 (instruction -> return_instr .)
    INTEGER         reduce using rule 19 (instruction -> return_instr .)
    FLOAT           reduce using rule 19 (instruction -> return_instr .)
    STRING          reduce using rule 19 (instruction -> return_instr .)
    $end            reduce using rule 19 (instruction -> return_instr .)
    UNTIL           reduce using rule 19 (instruction -> return_instr .)
    }               reduce using rule 19 (instruction -> return_instr .)
    ELSE            reduce using rule 19 (instruction -> return_instr .)


state 19

    (43) expression -> const .

    ;               reduce using rule 43 (expression -> const .)
    +               reduce using rule 43 (expression -> const .)
    -               reduce using rule 43 (expression -> const .)
    *               reduce using rule 43 (expression -> const .)
    /               reduce using rule 43 (expression -> const .)
    %               reduce using rule 43 (expression -> const .)
    |               reduce using rule 43 (expression -> const .)
    &               reduce using rule 43 (expression -> const .)
    ^               reduce using rule 43 (expression -> const .)
    AND             reduce using rule 43 (expression -> const .)
    OR              reduce using rule 43 (expression -> const .)
    SHL             reduce using rule 43 (expression -> const .)
    SHR             reduce using rule 43 (expression -> const .)
    EQ              reduce using rule 43 (expression -> const .)
    NEQ             reduce using rule 43 (expression -> const .)
    >               reduce using rule 43 (expression -> const .)
    <               reduce using rule 43 (expression -> const .)
    LE              reduce using rule 43 (expression -> const .)
    GE              reduce using rule 43 (expression -> const .)
    ,               reduce using rule 43 (expression -> const .)
    )               reduce using rule 43 (expression -> const .)


state 20

    (46) expression -> ( . expression )
    (47) expression -> ( . error )
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    error           shift and go to state 52
    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 53
    bin_expression                 shift and go to state 23

state 21

    (21) instruction -> continue_instr .

    PRINT           reduce using rule 21 (instruction -> continue_instr .)
    ID              reduce using rule 21 (instruction -> continue_instr .)
    IF              reduce using rule 21 (instruction -> continue_instr .)
    WHILE           reduce using rule 21 (instruction -> continue_instr .)
    REPEAT          reduce using rule 21 (instruction -> continue_instr .)
    RETURN          reduce using rule 21 (instruction -> continue_instr .)
    BREAK           reduce using rule 21 (instruction -> continue_instr .)
    CONTINUE        reduce using rule 21 (instruction -> continue_instr .)
    {               reduce using rule 21 (instruction -> continue_instr .)
    (               reduce using rule 21 (instruction -> continue_instr .)
    INTEGER         reduce using rule 21 (instruction -> continue_instr .)
    FLOAT           reduce using rule 21 (instruction -> continue_instr .)
    STRING          reduce using rule 21 (instruction -> continue_instr .)
    $end            reduce using rule 21 (instruction -> continue_instr .)
    UNTIL           reduce using rule 21 (instruction -> continue_instr .)
    }               reduce using rule 21 (instruction -> continue_instr .)
    ELSE            reduce using rule 21 (instruction -> continue_instr .)


state 22

    (17) instruction -> while_instr .

    PRINT           reduce using rule 17 (instruction -> while_instr .)
    ID              reduce using rule 17 (instruction -> while_instr .)
    IF              reduce using rule 17 (instruction -> while_instr .)
    WHILE           reduce using rule 17 (instruction -> while_instr .)
    REPEAT          reduce using rule 17 (instruction -> while_instr .)
    RETURN          reduce using rule 17 (instruction -> while_instr .)
    BREAK           reduce using rule 17 (instruction -> while_instr .)
    CONTINUE        reduce using rule 17 (instruction -> while_instr .)
    {               reduce using rule 17 (instruction -> while_instr .)
    (               reduce using rule 17 (instruction -> while_instr .)
    INTEGER         reduce using rule 17 (instruction -> while_instr .)
    FLOAT           reduce using rule 17 (instruction -> while_instr .)
    STRING          reduce using rule 17 (instruction -> while_instr .)
    $end            reduce using rule 17 (instruction -> while_instr .)
    UNTIL           reduce using rule 17 (instruction -> while_instr .)
    }               reduce using rule 17 (instruction -> while_instr .)
    ELSE            reduce using rule 17 (instruction -> while_instr .)


state 23

    (45) expression -> bin_expression .

    ;               reduce using rule 45 (expression -> bin_expression .)
    +               reduce using rule 45 (expression -> bin_expression .)
    -               reduce using rule 45 (expression -> bin_expression .)
    *               reduce using rule 45 (expression -> bin_expression .)
    /               reduce using rule 45 (expression -> bin_expression .)
    %               reduce using rule 45 (expression -> bin_expression .)
    |               reduce using rule 45 (expression -> bin_expression .)
    &               reduce using rule 45 (expression -> bin_expression .)
    ^               reduce using rule 45 (expression -> bin_expression .)
    AND             reduce using rule 45 (expression -> bin_expression .)
    OR              reduce using rule 45 (expression -> bin_expression .)
    SHL             reduce using rule 45 (expression -> bin_expression .)
    SHR             reduce using rule 45 (expression -> bin_expression .)
    EQ              reduce using rule 45 (expression -> bin_expression .)
    NEQ             reduce using rule 45 (expression -> bin_expression .)
    >               reduce using rule 45 (expression -> bin_expression .)
    <               reduce using rule 45 (expression -> bin_expression .)
    LE              reduce using rule 45 (expression -> bin_expression .)
    GE              reduce using rule 45 (expression -> bin_expression .)
    ,               reduce using rule 45 (expression -> bin_expression .)
    )               reduce using rule 45 (expression -> bin_expression .)


state 24

    (40) const -> INTEGER .

    +               reduce using rule 40 (const -> INTEGER .)
    -               reduce using rule 40 (const -> INTEGER .)
    *               reduce using rule 40 (const -> INTEGER .)
    /               reduce using rule 40 (const -> INTEGER .)
    %               reduce using rule 40 (const -> INTEGER .)
    |               reduce using rule 40 (const -> INTEGER .)
    &               reduce using rule 40 (const -> INTEGER .)
    ^               reduce using rule 40 (const -> INTEGER .)
    AND             reduce using rule 40 (const -> INTEGER .)
    OR              reduce using rule 40 (const -> INTEGER .)
    SHL             reduce using rule 40 (const -> INTEGER .)
    SHR             reduce using rule 40 (const -> INTEGER .)
    EQ              reduce using rule 40 (const -> INTEGER .)
    NEQ             reduce using rule 40 (const -> INTEGER .)
    >               reduce using rule 40 (const -> INTEGER .)
    <               reduce using rule 40 (const -> INTEGER .)
    LE              reduce using rule 40 (const -> INTEGER .)
    GE              reduce using rule 40 (const -> INTEGER .)
    ;               reduce using rule 40 (const -> INTEGER .)
    ,               reduce using rule 40 (const -> INTEGER .)
    )               reduce using rule 40 (const -> INTEGER .)


state 25

    (34) repeat_instr -> REPEAT . instructions UNTIL condition ;
    (11) instructions -> . instructions instruction
    (12) instructions -> . instruction
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expr_list ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { declarations instructions_opt }
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    PRINT           shift and go to state 15
    ID              shift and go to state 31
    IF              shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 25
    RETURN          shift and go to state 12
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 38
    {               shift and go to state 39
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    return_instr                   shift and go to state 18
    const                          shift and go to state 19
    assignment                     shift and go to state 27
    instruction                    shift and go to state 34
    compound_instr                 shift and go to state 30
    continue_instr                 shift and go to state 21
    labeled_instr                  shift and go to state 28
    print_instr                    shift and go to state 37
    choice_instr                   shift and go to state 13
    repeat_instr                   shift and go to state 17
    bin_expression                 shift and go to state 23
    break_instr                    shift and go to state 33
    while_instr                    shift and go to state 22
    expression                     shift and go to state 40
    instructions                   shift and go to state 54

state 26

    (42) const -> STRING .

    +               reduce using rule 42 (const -> STRING .)
    -               reduce using rule 42 (const -> STRING .)
    *               reduce using rule 42 (const -> STRING .)
    /               reduce using rule 42 (const -> STRING .)
    %               reduce using rule 42 (const -> STRING .)
    |               reduce using rule 42 (const -> STRING .)
    &               reduce using rule 42 (const -> STRING .)
    ^               reduce using rule 42 (const -> STRING .)
    AND             reduce using rule 42 (const -> STRING .)
    OR              reduce using rule 42 (const -> STRING .)
    SHL             reduce using rule 42 (const -> STRING .)
    SHR             reduce using rule 42 (const -> STRING .)
    EQ              reduce using rule 42 (const -> STRING .)
    NEQ             reduce using rule 42 (const -> STRING .)
    >               reduce using rule 42 (const -> STRING .)
    <               reduce using rule 42 (const -> STRING .)
    LE              reduce using rule 42 (const -> STRING .)
    GE              reduce using rule 42 (const -> STRING .)
    ;               reduce using rule 42 (const -> STRING .)
    ,               reduce using rule 42 (const -> STRING .)
    )               reduce using rule 42 (const -> STRING .)


state 27

    (15) instruction -> assignment .

    PRINT           reduce using rule 15 (instruction -> assignment .)
    ID              reduce using rule 15 (instruction -> assignment .)
    IF              reduce using rule 15 (instruction -> assignment .)
    WHILE           reduce using rule 15 (instruction -> assignment .)
    REPEAT          reduce using rule 15 (instruction -> assignment .)
    RETURN          reduce using rule 15 (instruction -> assignment .)
    BREAK           reduce using rule 15 (instruction -> assignment .)
    CONTINUE        reduce using rule 15 (instruction -> assignment .)
    {               reduce using rule 15 (instruction -> assignment .)
    (               reduce using rule 15 (instruction -> assignment .)
    INTEGER         reduce using rule 15 (instruction -> assignment .)
    FLOAT           reduce using rule 15 (instruction -> assignment .)
    STRING          reduce using rule 15 (instruction -> assignment .)
    $end            reduce using rule 15 (instruction -> assignment .)
    UNTIL           reduce using rule 15 (instruction -> assignment .)
    }               reduce using rule 15 (instruction -> assignment .)
    ELSE            reduce using rule 15 (instruction -> assignment .)


state 28

    (14) instruction -> labeled_instr .

    PRINT           reduce using rule 14 (instruction -> labeled_instr .)
    ID              reduce using rule 14 (instruction -> labeled_instr .)
    IF              reduce using rule 14 (instruction -> labeled_instr .)
    WHILE           reduce using rule 14 (instruction -> labeled_instr .)
    REPEAT          reduce using rule 14 (instruction -> labeled_instr .)
    RETURN          reduce using rule 14 (instruction -> labeled_instr .)
    BREAK           reduce using rule 14 (instruction -> labeled_instr .)
    CONTINUE        reduce using rule 14 (instruction -> labeled_instr .)
    {               reduce using rule 14 (instruction -> labeled_instr .)
    (               reduce using rule 14 (instruction -> labeled_instr .)
    INTEGER         reduce using rule 14 (instruction -> labeled_instr .)
    FLOAT           reduce using rule 14 (instruction -> labeled_instr .)
    STRING          reduce using rule 14 (instruction -> labeled_instr .)
    $end            reduce using rule 14 (instruction -> labeled_instr .)
    UNTIL           reduce using rule 14 (instruction -> labeled_instr .)
    }               reduce using rule 14 (instruction -> labeled_instr .)
    ELSE            reduce using rule 14 (instruction -> labeled_instr .)


state 29

    (1) program -> declarations fundefs_opt instructions_opt .

    $end            reduce using rule 1 (program -> declarations fundefs_opt instructions_opt .)


state 30

    (22) instruction -> compound_instr .

    PRINT           reduce using rule 22 (instruction -> compound_instr .)
    ID              reduce using rule 22 (instruction -> compound_instr .)
    IF              reduce using rule 22 (instruction -> compound_instr .)
    WHILE           reduce using rule 22 (instruction -> compound_instr .)
    REPEAT          reduce using rule 22 (instruction -> compound_instr .)
    RETURN          reduce using rule 22 (instruction -> compound_instr .)
    BREAK           reduce using rule 22 (instruction -> compound_instr .)
    CONTINUE        reduce using rule 22 (instruction -> compound_instr .)
    {               reduce using rule 22 (instruction -> compound_instr .)
    (               reduce using rule 22 (instruction -> compound_instr .)
    INTEGER         reduce using rule 22 (instruction -> compound_instr .)
    FLOAT           reduce using rule 22 (instruction -> compound_instr .)
    STRING          reduce using rule 22 (instruction -> compound_instr .)
    $end            reduce using rule 22 (instruction -> compound_instr .)
    UNTIL           reduce using rule 22 (instruction -> compound_instr .)
    }               reduce using rule 22 (instruction -> compound_instr .)
    ELSE            reduce using rule 22 (instruction -> compound_instr .)


state 31

    (26) labeled_instr -> ID . : instruction
    (27) assignment -> ID . = expression ;
    (44) expression -> ID .
    (48) expression -> ID . ( expr_list_or_empty )
    (49) expression -> ID . ( error )

    :               shift and go to state 56
    =               shift and go to state 57
    ;               reduce using rule 44 (expression -> ID .)
    +               reduce using rule 44 (expression -> ID .)
    -               reduce using rule 44 (expression -> ID .)
    *               reduce using rule 44 (expression -> ID .)
    /               reduce using rule 44 (expression -> ID .)
    %               reduce using rule 44 (expression -> ID .)
    |               reduce using rule 44 (expression -> ID .)
    &               reduce using rule 44 (expression -> ID .)
    ^               reduce using rule 44 (expression -> ID .)
    AND             reduce using rule 44 (expression -> ID .)
    OR              reduce using rule 44 (expression -> ID .)
    SHL             reduce using rule 44 (expression -> ID .)
    SHR             reduce using rule 44 (expression -> ID .)
    EQ              reduce using rule 44 (expression -> ID .)
    NEQ             reduce using rule 44 (expression -> ID .)
    >               reduce using rule 44 (expression -> ID .)
    <               reduce using rule 44 (expression -> ID .)
    LE              reduce using rule 44 (expression -> ID .)
    GE              reduce using rule 44 (expression -> ID .)
    (               shift and go to state 55


state 32

    (9) instructions_opt -> instructions .
    (11) instructions -> instructions . instruction
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expr_list ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { declarations instructions_opt }
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    $end            reduce using rule 9 (instructions_opt -> instructions .)
    }               reduce using rule 9 (instructions_opt -> instructions .)
    PRINT           shift and go to state 15
    ID              shift and go to state 31
    IF              shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 25
    RETURN          shift and go to state 12
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 38
    {               shift and go to state 39
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    return_instr                   shift and go to state 18
    const                          shift and go to state 19
    assignment                     shift and go to state 27
    instruction                    shift and go to state 58
    compound_instr                 shift and go to state 30
    continue_instr                 shift and go to state 21
    labeled_instr                  shift and go to state 28
    print_instr                    shift and go to state 37
    choice_instr                   shift and go to state 13
    bin_expression                 shift and go to state 23
    break_instr                    shift and go to state 33
    while_instr                    shift and go to state 22
    expression                     shift and go to state 40
    repeat_instr                   shift and go to state 17

state 33

    (20) instruction -> break_instr .

    PRINT           reduce using rule 20 (instruction -> break_instr .)
    ID              reduce using rule 20 (instruction -> break_instr .)
    IF              reduce using rule 20 (instruction -> break_instr .)
    WHILE           reduce using rule 20 (instruction -> break_instr .)
    REPEAT          reduce using rule 20 (instruction -> break_instr .)
    RETURN          reduce using rule 20 (instruction -> break_instr .)
    BREAK           reduce using rule 20 (instruction -> break_instr .)
    CONTINUE        reduce using rule 20 (instruction -> break_instr .)
    {               reduce using rule 20 (instruction -> break_instr .)
    (               reduce using rule 20 (instruction -> break_instr .)
    INTEGER         reduce using rule 20 (instruction -> break_instr .)
    FLOAT           reduce using rule 20 (instruction -> break_instr .)
    STRING          reduce using rule 20 (instruction -> break_instr .)
    $end            reduce using rule 20 (instruction -> break_instr .)
    UNTIL           reduce using rule 20 (instruction -> break_instr .)
    }               reduce using rule 20 (instruction -> break_instr .)
    ELSE            reduce using rule 20 (instruction -> break_instr .)


state 34

    (12) instructions -> instruction .

    PRINT           reduce using rule 12 (instructions -> instruction .)
    ID              reduce using rule 12 (instructions -> instruction .)
    IF              reduce using rule 12 (instructions -> instruction .)
    WHILE           reduce using rule 12 (instructions -> instruction .)
    REPEAT          reduce using rule 12 (instructions -> instruction .)
    RETURN          reduce using rule 12 (instructions -> instruction .)
    BREAK           reduce using rule 12 (instructions -> instruction .)
    CONTINUE        reduce using rule 12 (instructions -> instruction .)
    {               reduce using rule 12 (instructions -> instruction .)
    (               reduce using rule 12 (instructions -> instruction .)
    INTEGER         reduce using rule 12 (instructions -> instruction .)
    FLOAT           reduce using rule 12 (instructions -> instruction .)
    STRING          reduce using rule 12 (instructions -> instruction .)
    }               reduce using rule 12 (instructions -> instruction .)
    $end            reduce using rule 12 (instructions -> instruction .)
    UNTIL           reduce using rule 12 (instructions -> instruction .)


state 35

    (41) const -> FLOAT .

    +               reduce using rule 41 (const -> FLOAT .)
    -               reduce using rule 41 (const -> FLOAT .)
    *               reduce using rule 41 (const -> FLOAT .)
    /               reduce using rule 41 (const -> FLOAT .)
    %               reduce using rule 41 (const -> FLOAT .)
    |               reduce using rule 41 (const -> FLOAT .)
    &               reduce using rule 41 (const -> FLOAT .)
    ^               reduce using rule 41 (const -> FLOAT .)
    AND             reduce using rule 41 (const -> FLOAT .)
    OR              reduce using rule 41 (const -> FLOAT .)
    SHL             reduce using rule 41 (const -> FLOAT .)
    SHR             reduce using rule 41 (const -> FLOAT .)
    EQ              reduce using rule 41 (const -> FLOAT .)
    NEQ             reduce using rule 41 (const -> FLOAT .)
    >               reduce using rule 41 (const -> FLOAT .)
    <               reduce using rule 41 (const -> FLOAT .)
    LE              reduce using rule 41 (const -> FLOAT .)
    GE              reduce using rule 41 (const -> FLOAT .)
    ;               reduce using rule 41 (const -> FLOAT .)
    ,               reduce using rule 41 (const -> FLOAT .)
    )               reduce using rule 41 (const -> FLOAT .)


state 36

    (37) break_instr -> BREAK . ;

    ;               shift and go to state 59


state 37

    (13) instruction -> print_instr .

    PRINT           reduce using rule 13 (instruction -> print_instr .)
    ID              reduce using rule 13 (instruction -> print_instr .)
    IF              reduce using rule 13 (instruction -> print_instr .)
    WHILE           reduce using rule 13 (instruction -> print_instr .)
    REPEAT          reduce using rule 13 (instruction -> print_instr .)
    RETURN          reduce using rule 13 (instruction -> print_instr .)
    BREAK           reduce using rule 13 (instruction -> print_instr .)
    CONTINUE        reduce using rule 13 (instruction -> print_instr .)
    {               reduce using rule 13 (instruction -> print_instr .)
    (               reduce using rule 13 (instruction -> print_instr .)
    INTEGER         reduce using rule 13 (instruction -> print_instr .)
    FLOAT           reduce using rule 13 (instruction -> print_instr .)
    STRING          reduce using rule 13 (instruction -> print_instr .)
    $end            reduce using rule 13 (instruction -> print_instr .)
    UNTIL           reduce using rule 13 (instruction -> print_instr .)
    }               reduce using rule 13 (instruction -> print_instr .)
    ELSE            reduce using rule 13 (instruction -> print_instr .)


state 38

    (36) continue_instr -> CONTINUE . ;

    ;               shift and go to state 60


state 39

    (38) compound_instr -> { . declarations instructions_opt }
    (2) declarations -> . declarations declaration
    (3) declarations -> .

    TYPE            reduce using rule 3 (declarations -> .)
    error           reduce using rule 3 (declarations -> .)
    PRINT           reduce using rule 3 (declarations -> .)
    ID              reduce using rule 3 (declarations -> .)
    IF              reduce using rule 3 (declarations -> .)
    WHILE           reduce using rule 3 (declarations -> .)
    REPEAT          reduce using rule 3 (declarations -> .)
    RETURN          reduce using rule 3 (declarations -> .)
    BREAK           reduce using rule 3 (declarations -> .)
    CONTINUE        reduce using rule 3 (declarations -> .)
    {               reduce using rule 3 (declarations -> .)
    (               reduce using rule 3 (declarations -> .)
    INTEGER         reduce using rule 3 (declarations -> .)
    FLOAT           reduce using rule 3 (declarations -> .)
    STRING          reduce using rule 3 (declarations -> .)
    }               reduce using rule 3 (declarations -> .)

    declarations                   shift and go to state 61

state 40

    (23) instruction -> expression . ;
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               shift and go to state 77
    +               shift and go to state 69
    -               shift and go to state 71
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65
    |               shift and go to state 79
    &               shift and go to state 66
    ^               shift and go to state 80
    AND             shift and go to state 62
    OR              shift and go to state 73
    SHL             shift and go to state 68
    SHR             shift and go to state 63
    EQ              shift and go to state 74
    NEQ             shift and go to state 78
    >               shift and go to state 75
    <               shift and go to state 67
    LE              shift and go to state 64
    GE              shift and go to state 76


state 41

    (7) inits -> init .

    ;               reduce using rule 7 (inits -> init .)
    ,               reduce using rule 7 (inits -> init .)


state 42

    (4) declaration -> TYPE inits . ;
    (6) inits -> inits . , init

    ;               shift and go to state 81
    ,               shift and go to state 82


state 43

    (76) fundef -> TYPE ID . ( args_list_or_empty ) compound_instr
    (8) init -> ID . = expression

    (               shift and go to state 83
    =               shift and go to state 84


state 44

    (76) fundef -> TYPE ID . ( args_list_or_empty ) compound_instr

    (               shift and go to state 83


state 45

    (44) expression -> ID .
    (48) expression -> ID . ( expr_list_or_empty )
    (49) expression -> ID . ( error )

    +               reduce using rule 44 (expression -> ID .)
    -               reduce using rule 44 (expression -> ID .)
    *               reduce using rule 44 (expression -> ID .)
    /               reduce using rule 44 (expression -> ID .)
    %               reduce using rule 44 (expression -> ID .)
    |               reduce using rule 44 (expression -> ID .)
    &               reduce using rule 44 (expression -> ID .)
    ^               reduce using rule 44 (expression -> ID .)
    AND             reduce using rule 44 (expression -> ID .)
    OR              reduce using rule 44 (expression -> ID .)
    SHL             reduce using rule 44 (expression -> ID .)
    SHR             reduce using rule 44 (expression -> ID .)
    EQ              reduce using rule 44 (expression -> ID .)
    NEQ             reduce using rule 44 (expression -> ID .)
    >               reduce using rule 44 (expression -> ID .)
    <               reduce using rule 44 (expression -> ID .)
    LE              reduce using rule 44 (expression -> ID .)
    GE              reduce using rule 44 (expression -> ID .)
    ;               reduce using rule 44 (expression -> ID .)
    ,               reduce using rule 44 (expression -> ID .)
    )               reduce using rule 44 (expression -> ID .)
    (               shift and go to state 55


state 46

    (35) return_instr -> RETURN expression . ;
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               shift and go to state 85
    +               shift and go to state 69
    -               shift and go to state 71
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65
    |               shift and go to state 79
    &               shift and go to state 66
    ^               shift and go to state 80
    AND             shift and go to state 62
    OR              shift and go to state 73
    SHL             shift and go to state 68
    SHR             shift and go to state 63
    EQ              shift and go to state 74
    NEQ             shift and go to state 78
    >               shift and go to state 75
    <               shift and go to state 67
    LE              shift and go to state 64
    GE              shift and go to state 76


state 47

    (28) choice_instr -> IF ( . condition ) instruction
    (29) choice_instr -> IF ( . condition ) instruction ELSE instruction
    (30) choice_instr -> IF ( . error ) instruction
    (31) choice_instr -> IF ( . error ) instruction ELSE instruction
    (39) condition -> . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    error           shift and go to state 87
    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    condition                      shift and go to state 86
    expression                     shift and go to state 88
    bin_expression                 shift and go to state 23

state 48

    (24) print_instr -> PRINT expr_list . ;
    (70) expr_list -> expr_list . , expression

    ;               shift and go to state 89
    ,               shift and go to state 90


state 49

    (25) print_instr -> PRINT error . ;

    ;               shift and go to state 91


state 50

    (71) expr_list -> expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ,               reduce using rule 71 (expr_list -> expression .)
    )               reduce using rule 71 (expr_list -> expression .)
    ;               reduce using rule 71 (expr_list -> expression .)
    +               shift and go to state 69
    -               shift and go to state 71
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65
    |               shift and go to state 79
    &               shift and go to state 66
    ^               shift and go to state 80
    AND             shift and go to state 62
    OR              shift and go to state 73
    SHL             shift and go to state 68
    SHR             shift and go to state 63
    EQ              shift and go to state 74
    NEQ             shift and go to state 78
    >               shift and go to state 75
    <               shift and go to state 67
    LE              shift and go to state 64
    GE              shift and go to state 76


state 51

    (32) while_instr -> WHILE ( . condition ) instruction
    (33) while_instr -> WHILE ( . error ) instruction
    (39) condition -> . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    error           shift and go to state 93
    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    condition                      shift and go to state 92
    expression                     shift and go to state 88
    bin_expression                 shift and go to state 23

state 52

    (47) expression -> ( error . )

    )               shift and go to state 94


state 53

    (46) expression -> ( expression . )
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    )               shift and go to state 95
    +               shift and go to state 69
    -               shift and go to state 71
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65
    |               shift and go to state 79
    &               shift and go to state 66
    ^               shift and go to state 80
    AND             shift and go to state 62
    OR              shift and go to state 73
    SHL             shift and go to state 68
    SHR             shift and go to state 63
    EQ              shift and go to state 74
    NEQ             shift and go to state 78
    >               shift and go to state 75
    <               shift and go to state 67
    LE              shift and go to state 64
    GE              shift and go to state 76


state 54

    (34) repeat_instr -> REPEAT instructions . UNTIL condition ;
    (11) instructions -> instructions . instruction
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expr_list ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { declarations instructions_opt }
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    UNTIL           shift and go to state 96
    PRINT           shift and go to state 15
    ID              shift and go to state 31
    IF              shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 25
    RETURN          shift and go to state 12
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 38
    {               shift and go to state 39
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    return_instr                   shift and go to state 18
    const                          shift and go to state 19
    assignment                     shift and go to state 27
    instruction                    shift and go to state 58
    compound_instr                 shift and go to state 30
    continue_instr                 shift and go to state 21
    labeled_instr                  shift and go to state 28
    print_instr                    shift and go to state 37
    choice_instr                   shift and go to state 13
    repeat_instr                   shift and go to state 17
    bin_expression                 shift and go to state 23
    break_instr                    shift and go to state 33
    while_instr                    shift and go to state 22
    expression                     shift and go to state 40

state 55

    (48) expression -> ID ( . expr_list_or_empty )
    (49) expression -> ID ( . error )
    (68) expr_list_or_empty -> . expr_list
    (69) expr_list_or_empty -> .
    (70) expr_list -> . expr_list , expression
    (71) expr_list -> . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    error           shift and go to state 99
    )               reduce using rule 69 (expr_list_or_empty -> .)
    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    expr_list                      shift and go to state 97
    expr_list_or_empty             shift and go to state 98
    expression                     shift and go to state 50
    bin_expression                 shift and go to state 23
    const                          shift and go to state 19

state 56

    (26) labeled_instr -> ID : . instruction
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expr_list ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { declarations instructions_opt }
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    PRINT           shift and go to state 15
    ID              shift and go to state 31
    IF              shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 25
    RETURN          shift and go to state 12
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 38
    {               shift and go to state 39
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    return_instr                   shift and go to state 18
    const                          shift and go to state 19
    assignment                     shift and go to state 27
    instruction                    shift and go to state 100
    compound_instr                 shift and go to state 30
    continue_instr                 shift and go to state 21
    while_instr                    shift and go to state 22
    print_instr                    shift and go to state 37
    choice_instr                   shift and go to state 13
    bin_expression                 shift and go to state 23
    break_instr                    shift and go to state 33
    labeled_instr                  shift and go to state 28
    expression                     shift and go to state 40
    repeat_instr                   shift and go to state 17

state 57

    (27) assignment -> ID = . expression ;
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 101
    bin_expression                 shift and go to state 23

state 58

    (11) instructions -> instructions instruction .

    PRINT           reduce using rule 11 (instructions -> instructions instruction .)
    ID              reduce using rule 11 (instructions -> instructions instruction .)
    IF              reduce using rule 11 (instructions -> instructions instruction .)
    WHILE           reduce using rule 11 (instructions -> instructions instruction .)
    REPEAT          reduce using rule 11 (instructions -> instructions instruction .)
    RETURN          reduce using rule 11 (instructions -> instructions instruction .)
    BREAK           reduce using rule 11 (instructions -> instructions instruction .)
    CONTINUE        reduce using rule 11 (instructions -> instructions instruction .)
    {               reduce using rule 11 (instructions -> instructions instruction .)
    (               reduce using rule 11 (instructions -> instructions instruction .)
    INTEGER         reduce using rule 11 (instructions -> instructions instruction .)
    FLOAT           reduce using rule 11 (instructions -> instructions instruction .)
    STRING          reduce using rule 11 (instructions -> instructions instruction .)
    }               reduce using rule 11 (instructions -> instructions instruction .)
    $end            reduce using rule 11 (instructions -> instructions instruction .)
    UNTIL           reduce using rule 11 (instructions -> instructions instruction .)


state 59

    (37) break_instr -> BREAK ; .

    PRINT           reduce using rule 37 (break_instr -> BREAK ; .)
    ID              reduce using rule 37 (break_instr -> BREAK ; .)
    IF              reduce using rule 37 (break_instr -> BREAK ; .)
    WHILE           reduce using rule 37 (break_instr -> BREAK ; .)
    REPEAT          reduce using rule 37 (break_instr -> BREAK ; .)
    RETURN          reduce using rule 37 (break_instr -> BREAK ; .)
    BREAK           reduce using rule 37 (break_instr -> BREAK ; .)
    CONTINUE        reduce using rule 37 (break_instr -> BREAK ; .)
    {               reduce using rule 37 (break_instr -> BREAK ; .)
    (               reduce using rule 37 (break_instr -> BREAK ; .)
    INTEGER         reduce using rule 37 (break_instr -> BREAK ; .)
    FLOAT           reduce using rule 37 (break_instr -> BREAK ; .)
    STRING          reduce using rule 37 (break_instr -> BREAK ; .)
    $end            reduce using rule 37 (break_instr -> BREAK ; .)
    }               reduce using rule 37 (break_instr -> BREAK ; .)
    UNTIL           reduce using rule 37 (break_instr -> BREAK ; .)
    ELSE            reduce using rule 37 (break_instr -> BREAK ; .)


state 60

    (36) continue_instr -> CONTINUE ; .

    UNTIL           reduce using rule 36 (continue_instr -> CONTINUE ; .)
    PRINT           reduce using rule 36 (continue_instr -> CONTINUE ; .)
    ID              reduce using rule 36 (continue_instr -> CONTINUE ; .)
    IF              reduce using rule 36 (continue_instr -> CONTINUE ; .)
    WHILE           reduce using rule 36 (continue_instr -> CONTINUE ; .)
    REPEAT          reduce using rule 36 (continue_instr -> CONTINUE ; .)
    RETURN          reduce using rule 36 (continue_instr -> CONTINUE ; .)
    BREAK           reduce using rule 36 (continue_instr -> CONTINUE ; .)
    CONTINUE        reduce using rule 36 (continue_instr -> CONTINUE ; .)
    {               reduce using rule 36 (continue_instr -> CONTINUE ; .)
    (               reduce using rule 36 (continue_instr -> CONTINUE ; .)
    INTEGER         reduce using rule 36 (continue_instr -> CONTINUE ; .)
    FLOAT           reduce using rule 36 (continue_instr -> CONTINUE ; .)
    STRING          reduce using rule 36 (continue_instr -> CONTINUE ; .)
    $end            reduce using rule 36 (continue_instr -> CONTINUE ; .)
    }               reduce using rule 36 (continue_instr -> CONTINUE ; .)
    ELSE            reduce using rule 36 (continue_instr -> CONTINUE ; .)


state 61

    (38) compound_instr -> { declarations . instructions_opt }
    (2) declarations -> declarations . declaration
    (9) instructions_opt -> . instructions
    (10) instructions_opt -> .
    (4) declaration -> . TYPE inits ;
    (5) declaration -> . error ;
    (11) instructions -> . instructions instruction
    (12) instructions -> . instruction
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expr_list ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { declarations instructions_opt }
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    }               reduce using rule 10 (instructions_opt -> .)
    TYPE            shift and go to state 103
    error           shift and go to state 3
    PRINT           shift and go to state 15
    ID              shift and go to state 31
    IF              shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 25
    RETURN          shift and go to state 12
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 38
    {               shift and go to state 39
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    instruction                    shift and go to state 34
    choice_instr                   shift and go to state 13
    repeat_instr                   shift and go to state 17
    return_instr                   shift and go to state 18
    const                          shift and go to state 19
    continue_instr                 shift and go to state 21
    while_instr                    shift and go to state 22
    bin_expression                 shift and go to state 23
    assignment                     shift and go to state 27
    labeled_instr                  shift and go to state 28
    instructions_opt               shift and go to state 102
    compound_instr                 shift and go to state 30
    declaration                    shift and go to state 7
    instructions                   shift and go to state 32
    break_instr                    shift and go to state 33
    print_instr                    shift and go to state 37
    expression                     shift and go to state 40

state 62

    (58) bin_expression -> expression AND . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 104
    bin_expression                 shift and go to state 23

state 63

    (61) bin_expression -> expression SHR . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 105
    bin_expression                 shift and go to state 23

state 64

    (66) bin_expression -> expression LE . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 106
    bin_expression                 shift and go to state 23

state 65

    (54) bin_expression -> expression % . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 107
    bin_expression                 shift and go to state 23

state 66

    (56) bin_expression -> expression & . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 108
    bin_expression                 shift and go to state 23

state 67

    (65) bin_expression -> expression < . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 109
    bin_expression                 shift and go to state 23

state 68

    (60) bin_expression -> expression SHL . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 110
    bin_expression                 shift and go to state 23

state 69

    (50) bin_expression -> expression + . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 111
    bin_expression                 shift and go to state 23

state 70

    (52) bin_expression -> expression * . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 112
    bin_expression                 shift and go to state 23

state 71

    (51) bin_expression -> expression - . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 113
    bin_expression                 shift and go to state 23

state 72

    (53) bin_expression -> expression / . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 114
    bin_expression                 shift and go to state 23

state 73

    (59) bin_expression -> expression OR . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 115
    bin_expression                 shift and go to state 23

state 74

    (62) bin_expression -> expression EQ . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 116
    bin_expression                 shift and go to state 23

state 75

    (64) bin_expression -> expression > . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 117
    bin_expression                 shift and go to state 23

state 76

    (67) bin_expression -> expression GE . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 118
    bin_expression                 shift and go to state 23

state 77

    (23) instruction -> expression ; .

    PRINT           reduce using rule 23 (instruction -> expression ; .)
    ID              reduce using rule 23 (instruction -> expression ; .)
    IF              reduce using rule 23 (instruction -> expression ; .)
    WHILE           reduce using rule 23 (instruction -> expression ; .)
    REPEAT          reduce using rule 23 (instruction -> expression ; .)
    RETURN          reduce using rule 23 (instruction -> expression ; .)
    BREAK           reduce using rule 23 (instruction -> expression ; .)
    CONTINUE        reduce using rule 23 (instruction -> expression ; .)
    {               reduce using rule 23 (instruction -> expression ; .)
    (               reduce using rule 23 (instruction -> expression ; .)
    INTEGER         reduce using rule 23 (instruction -> expression ; .)
    FLOAT           reduce using rule 23 (instruction -> expression ; .)
    STRING          reduce using rule 23 (instruction -> expression ; .)
    $end            reduce using rule 23 (instruction -> expression ; .)
    UNTIL           reduce using rule 23 (instruction -> expression ; .)
    }               reduce using rule 23 (instruction -> expression ; .)
    ELSE            reduce using rule 23 (instruction -> expression ; .)


state 78

    (63) bin_expression -> expression NEQ . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 119
    bin_expression                 shift and go to state 23

state 79

    (55) bin_expression -> expression | . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 120
    bin_expression                 shift and go to state 23

state 80

    (57) bin_expression -> expression ^ . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 121
    bin_expression                 shift and go to state 23

state 81

    (4) declaration -> TYPE inits ; .

    TYPE            reduce using rule 4 (declaration -> TYPE inits ; .)
    error           reduce using rule 4 (declaration -> TYPE inits ; .)
    PRINT           reduce using rule 4 (declaration -> TYPE inits ; .)
    ID              reduce using rule 4 (declaration -> TYPE inits ; .)
    IF              reduce using rule 4 (declaration -> TYPE inits ; .)
    WHILE           reduce using rule 4 (declaration -> TYPE inits ; .)
    REPEAT          reduce using rule 4 (declaration -> TYPE inits ; .)
    RETURN          reduce using rule 4 (declaration -> TYPE inits ; .)
    BREAK           reduce using rule 4 (declaration -> TYPE inits ; .)
    CONTINUE        reduce using rule 4 (declaration -> TYPE inits ; .)
    {               reduce using rule 4 (declaration -> TYPE inits ; .)
    (               reduce using rule 4 (declaration -> TYPE inits ; .)
    INTEGER         reduce using rule 4 (declaration -> TYPE inits ; .)
    FLOAT           reduce using rule 4 (declaration -> TYPE inits ; .)
    STRING          reduce using rule 4 (declaration -> TYPE inits ; .)
    $end            reduce using rule 4 (declaration -> TYPE inits ; .)
    }               reduce using rule 4 (declaration -> TYPE inits ; .)


state 82

    (6) inits -> inits , . init
    (8) init -> . ID = expression

    ID              shift and go to state 123

    init                           shift and go to state 122

state 83

    (76) fundef -> TYPE ID ( . args_list_or_empty ) compound_instr
    (77) args_list_or_empty -> . args_list
    (78) args_list_or_empty -> .
    (79) args_list -> . args_list , arg
    (80) args_list -> . arg
    (81) arg -> . TYPE ID

    )               reduce using rule 78 (args_list_or_empty -> .)
    TYPE            shift and go to state 127

    args_list_or_empty             shift and go to state 125
    arg                            shift and go to state 126
    args_list                      shift and go to state 124

state 84

    (8) init -> ID = . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    const                          shift and go to state 19
    expression                     shift and go to state 128
    bin_expression                 shift and go to state 23

state 85

    (35) return_instr -> RETURN expression ; .

    PRINT           reduce using rule 35 (return_instr -> RETURN expression ; .)
    ID              reduce using rule 35 (return_instr -> RETURN expression ; .)
    IF              reduce using rule 35 (return_instr -> RETURN expression ; .)
    WHILE           reduce using rule 35 (return_instr -> RETURN expression ; .)
    REPEAT          reduce using rule 35 (return_instr -> RETURN expression ; .)
    RETURN          reduce using rule 35 (return_instr -> RETURN expression ; .)
    BREAK           reduce using rule 35 (return_instr -> RETURN expression ; .)
    CONTINUE        reduce using rule 35 (return_instr -> RETURN expression ; .)
    {               reduce using rule 35 (return_instr -> RETURN expression ; .)
    (               reduce using rule 35 (return_instr -> RETURN expression ; .)
    INTEGER         reduce using rule 35 (return_instr -> RETURN expression ; .)
    FLOAT           reduce using rule 35 (return_instr -> RETURN expression ; .)
    STRING          reduce using rule 35 (return_instr -> RETURN expression ; .)
    $end            reduce using rule 35 (return_instr -> RETURN expression ; .)
    }               reduce using rule 35 (return_instr -> RETURN expression ; .)
    UNTIL           reduce using rule 35 (return_instr -> RETURN expression ; .)
    ELSE            reduce using rule 35 (return_instr -> RETURN expression ; .)


state 86

    (28) choice_instr -> IF ( condition . ) instruction
    (29) choice_instr -> IF ( condition . ) instruction ELSE instruction

    )               shift and go to state 129


state 87

    (30) choice_instr -> IF ( error . ) instruction
    (31) choice_instr -> IF ( error . ) instruction ELSE instruction

    )               shift and go to state 130


state 88

    (39) condition -> expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    )               reduce using rule 39 (condition -> expression .)
    ;               reduce using rule 39 (condition -> expression .)
    +               shift and go to state 69
    -               shift and go to state 71
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65
    |               shift and go to state 79
    &               shift and go to state 66
    ^               shift and go to state 80
    AND             shift and go to state 62
    OR              shift and go to state 73
    SHL             shift and go to state 68
    SHR             shift and go to state 63
    EQ              shift and go to state 74
    NEQ             shift and go to state 78
    >               shift and go to state 75
    <               shift and go to state 67
    LE              shift and go to state 64
    GE              shift and go to state 76


state 89

    (24) print_instr -> PRINT expr_list ; .

    PRINT           reduce using rule 24 (print_instr -> PRINT expr_list ; .)
    ID              reduce using rule 24 (print_instr -> PRINT expr_list ; .)
    IF              reduce using rule 24 (print_instr -> PRINT expr_list ; .)
    WHILE           reduce using rule 24 (print_instr -> PRINT expr_list ; .)
    REPEAT          reduce using rule 24 (print_instr -> PRINT expr_list ; .)
    RETURN          reduce using rule 24 (print_instr -> PRINT expr_list ; .)
    BREAK           reduce using rule 24 (print_instr -> PRINT expr_list ; .)
    CONTINUE        reduce using rule 24 (print_instr -> PRINT expr_list ; .)
    {               reduce using rule 24 (print_instr -> PRINT expr_list ; .)
    (               reduce using rule 24 (print_instr -> PRINT expr_list ; .)
    INTEGER         reduce using rule 24 (print_instr -> PRINT expr_list ; .)
    FLOAT           reduce using rule 24 (print_instr -> PRINT expr_list ; .)
    STRING          reduce using rule 24 (print_instr -> PRINT expr_list ; .)
    $end            reduce using rule 24 (print_instr -> PRINT expr_list ; .)
    UNTIL           reduce using rule 24 (print_instr -> PRINT expr_list ; .)
    }               reduce using rule 24 (print_instr -> PRINT expr_list ; .)
    ELSE            reduce using rule 24 (print_instr -> PRINT expr_list ; .)


state 90

    (70) expr_list -> expr_list , . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    expression                     shift and go to state 131
    bin_expression                 shift and go to state 23
    const                          shift and go to state 19

state 91

    (25) print_instr -> PRINT error ; .

    PRINT           reduce using rule 25 (print_instr -> PRINT error ; .)
    ID              reduce using rule 25 (print_instr -> PRINT error ; .)
    IF              reduce using rule 25 (print_instr -> PRINT error ; .)
    WHILE           reduce using rule 25 (print_instr -> PRINT error ; .)
    REPEAT          reduce using rule 25 (print_instr -> PRINT error ; .)
    RETURN          reduce using rule 25 (print_instr -> PRINT error ; .)
    BREAK           reduce using rule 25 (print_instr -> PRINT error ; .)
    CONTINUE        reduce using rule 25 (print_instr -> PRINT error ; .)
    {               reduce using rule 25 (print_instr -> PRINT error ; .)
    (               reduce using rule 25 (print_instr -> PRINT error ; .)
    INTEGER         reduce using rule 25 (print_instr -> PRINT error ; .)
    FLOAT           reduce using rule 25 (print_instr -> PRINT error ; .)
    STRING          reduce using rule 25 (print_instr -> PRINT error ; .)
    $end            reduce using rule 25 (print_instr -> PRINT error ; .)
    UNTIL           reduce using rule 25 (print_instr -> PRINT error ; .)
    }               reduce using rule 25 (print_instr -> PRINT error ; .)
    ELSE            reduce using rule 25 (print_instr -> PRINT error ; .)


state 92

    (32) while_instr -> WHILE ( condition . ) instruction

    )               shift and go to state 132


state 93

    (33) while_instr -> WHILE ( error . ) instruction

    )               shift and go to state 133


state 94

    (47) expression -> ( error ) .

    ;               reduce using rule 47 (expression -> ( error ) .)
    +               reduce using rule 47 (expression -> ( error ) .)
    -               reduce using rule 47 (expression -> ( error ) .)
    *               reduce using rule 47 (expression -> ( error ) .)
    /               reduce using rule 47 (expression -> ( error ) .)
    %               reduce using rule 47 (expression -> ( error ) .)
    |               reduce using rule 47 (expression -> ( error ) .)
    &               reduce using rule 47 (expression -> ( error ) .)
    ^               reduce using rule 47 (expression -> ( error ) .)
    AND             reduce using rule 47 (expression -> ( error ) .)
    OR              reduce using rule 47 (expression -> ( error ) .)
    SHL             reduce using rule 47 (expression -> ( error ) .)
    SHR             reduce using rule 47 (expression -> ( error ) .)
    EQ              reduce using rule 47 (expression -> ( error ) .)
    NEQ             reduce using rule 47 (expression -> ( error ) .)
    >               reduce using rule 47 (expression -> ( error ) .)
    <               reduce using rule 47 (expression -> ( error ) .)
    LE              reduce using rule 47 (expression -> ( error ) .)
    GE              reduce using rule 47 (expression -> ( error ) .)
    ,               reduce using rule 47 (expression -> ( error ) .)
    )               reduce using rule 47 (expression -> ( error ) .)


state 95

    (46) expression -> ( expression ) .

    ;               reduce using rule 46 (expression -> ( expression ) .)
    +               reduce using rule 46 (expression -> ( expression ) .)
    -               reduce using rule 46 (expression -> ( expression ) .)
    *               reduce using rule 46 (expression -> ( expression ) .)
    /               reduce using rule 46 (expression -> ( expression ) .)
    %               reduce using rule 46 (expression -> ( expression ) .)
    |               reduce using rule 46 (expression -> ( expression ) .)
    &               reduce using rule 46 (expression -> ( expression ) .)
    ^               reduce using rule 46 (expression -> ( expression ) .)
    AND             reduce using rule 46 (expression -> ( expression ) .)
    OR              reduce using rule 46 (expression -> ( expression ) .)
    SHL             reduce using rule 46 (expression -> ( expression ) .)
    SHR             reduce using rule 46 (expression -> ( expression ) .)
    EQ              reduce using rule 46 (expression -> ( expression ) .)
    NEQ             reduce using rule 46 (expression -> ( expression ) .)
    >               reduce using rule 46 (expression -> ( expression ) .)
    <               reduce using rule 46 (expression -> ( expression ) .)
    LE              reduce using rule 46 (expression -> ( expression ) .)
    GE              reduce using rule 46 (expression -> ( expression ) .)
    ,               reduce using rule 46 (expression -> ( expression ) .)
    )               reduce using rule 46 (expression -> ( expression ) .)


state 96

    (34) repeat_instr -> REPEAT instructions UNTIL . condition ;
    (39) condition -> . expression
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    ID              shift and go to state 45
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    condition                      shift and go to state 134
    const                          shift and go to state 19
    expression                     shift and go to state 88
    bin_expression                 shift and go to state 23

state 97

    (68) expr_list_or_empty -> expr_list .
    (70) expr_list -> expr_list . , expression

    )               reduce using rule 68 (expr_list_or_empty -> expr_list .)
    ,               shift and go to state 90


state 98

    (48) expression -> ID ( expr_list_or_empty . )

    )               shift and go to state 135


state 99

    (49) expression -> ID ( error . )

    )               shift and go to state 136


state 100

    (26) labeled_instr -> ID : instruction .

    PRINT           reduce using rule 26 (labeled_instr -> ID : instruction .)
    ID              reduce using rule 26 (labeled_instr -> ID : instruction .)
    IF              reduce using rule 26 (labeled_instr -> ID : instruction .)
    WHILE           reduce using rule 26 (labeled_instr -> ID : instruction .)
    REPEAT          reduce using rule 26 (labeled_instr -> ID : instruction .)
    RETURN          reduce using rule 26 (labeled_instr -> ID : instruction .)
    BREAK           reduce using rule 26 (labeled_instr -> ID : instruction .)
    CONTINUE        reduce using rule 26 (labeled_instr -> ID : instruction .)
    {               reduce using rule 26 (labeled_instr -> ID : instruction .)
    (               reduce using rule 26 (labeled_instr -> ID : instruction .)
    INTEGER         reduce using rule 26 (labeled_instr -> ID : instruction .)
    FLOAT           reduce using rule 26 (labeled_instr -> ID : instruction .)
    STRING          reduce using rule 26 (labeled_instr -> ID : instruction .)
    $end            reduce using rule 26 (labeled_instr -> ID : instruction .)
    }               reduce using rule 26 (labeled_instr -> ID : instruction .)
    UNTIL           reduce using rule 26 (labeled_instr -> ID : instruction .)
    ELSE            reduce using rule 26 (labeled_instr -> ID : instruction .)


state 101

    (27) assignment -> ID = expression . ;
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               shift and go to state 137
    +               shift and go to state 69
    -               shift and go to state 71
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65
    |               shift and go to state 79
    &               shift and go to state 66
    ^               shift and go to state 80
    AND             shift and go to state 62
    OR              shift and go to state 73
    SHL             shift and go to state 68
    SHR             shift and go to state 63
    EQ              shift and go to state 74
    NEQ             shift and go to state 78
    >               shift and go to state 75
    <               shift and go to state 67
    LE              shift and go to state 64
    GE              shift and go to state 76


state 102

    (38) compound_instr -> { declarations instructions_opt . }

    }               shift and go to state 138


state 103

    (4) declaration -> TYPE . inits ;
    (6) inits -> . inits , init
    (7) inits -> . init
    (8) init -> . ID = expression

    ID              shift and go to state 123

    init                           shift and go to state 41
    inits                          shift and go to state 42

state 104

    (58) bin_expression -> expression AND expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               reduce using rule 58 (bin_expression -> expression AND expression .)
    AND             reduce using rule 58 (bin_expression -> expression AND expression .)
    OR              reduce using rule 58 (bin_expression -> expression AND expression .)
    ,               reduce using rule 58 (bin_expression -> expression AND expression .)
    )               reduce using rule 58 (bin_expression -> expression AND expression .)
    +               shift and go to state 69
    -               shift and go to state 71
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65
    |               shift and go to state 79
    &               shift and go to state 66
    ^               shift and go to state 80
    SHL             shift and go to state 68
    SHR             shift and go to state 63
    EQ              shift and go to state 74
    NEQ             shift and go to state 78
    >               shift and go to state 75
    <               shift and go to state 67
    LE              shift and go to state 64
    GE              shift and go to state 76

  ! +               [ reduce using rule 58 (bin_expression -> expression AND expression .) ]
  ! -               [ reduce using rule 58 (bin_expression -> expression AND expression .) ]
  ! *               [ reduce using rule 58 (bin_expression -> expression AND expression .) ]
  ! /               [ reduce using rule 58 (bin_expression -> expression AND expression .) ]
  ! %               [ reduce using rule 58 (bin_expression -> expression AND expression .) ]
  ! |               [ reduce using rule 58 (bin_expression -> expression AND expression .) ]
  ! &               [ reduce using rule 58 (bin_expression -> expression AND expression .) ]
  ! ^               [ reduce using rule 58 (bin_expression -> expression AND expression .) ]
  ! SHL             [ reduce using rule 58 (bin_expression -> expression AND expression .) ]
  ! SHR             [ reduce using rule 58 (bin_expression -> expression AND expression .) ]
  ! EQ              [ reduce using rule 58 (bin_expression -> expression AND expression .) ]
  ! NEQ             [ reduce using rule 58 (bin_expression -> expression AND expression .) ]
  ! >               [ reduce using rule 58 (bin_expression -> expression AND expression .) ]
  ! <               [ reduce using rule 58 (bin_expression -> expression AND expression .) ]
  ! LE              [ reduce using rule 58 (bin_expression -> expression AND expression .) ]
  ! GE              [ reduce using rule 58 (bin_expression -> expression AND expression .) ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 73 ]


state 105

    (61) bin_expression -> expression SHR expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               reduce using rule 61 (bin_expression -> expression SHR expression .)
    |               reduce using rule 61 (bin_expression -> expression SHR expression .)
    &               reduce using rule 61 (bin_expression -> expression SHR expression .)
    ^               reduce using rule 61 (bin_expression -> expression SHR expression .)
    AND             reduce using rule 61 (bin_expression -> expression SHR expression .)
    OR              reduce using rule 61 (bin_expression -> expression SHR expression .)
    SHL             reduce using rule 61 (bin_expression -> expression SHR expression .)
    SHR             reduce using rule 61 (bin_expression -> expression SHR expression .)
    EQ              reduce using rule 61 (bin_expression -> expression SHR expression .)
    NEQ             reduce using rule 61 (bin_expression -> expression SHR expression .)
    >               reduce using rule 61 (bin_expression -> expression SHR expression .)
    <               reduce using rule 61 (bin_expression -> expression SHR expression .)
    LE              reduce using rule 61 (bin_expression -> expression SHR expression .)
    GE              reduce using rule 61 (bin_expression -> expression SHR expression .)
    ,               reduce using rule 61 (bin_expression -> expression SHR expression .)
    )               reduce using rule 61 (bin_expression -> expression SHR expression .)
    +               shift and go to state 69
    -               shift and go to state 71
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65

  ! +               [ reduce using rule 61 (bin_expression -> expression SHR expression .) ]
  ! -               [ reduce using rule 61 (bin_expression -> expression SHR expression .) ]
  ! *               [ reduce using rule 61 (bin_expression -> expression SHR expression .) ]
  ! /               [ reduce using rule 61 (bin_expression -> expression SHR expression .) ]
  ! %               [ reduce using rule 61 (bin_expression -> expression SHR expression .) ]
  ! |               [ shift and go to state 79 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 80 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 73 ]
  ! SHL             [ shift and go to state 68 ]
  ! SHR             [ shift and go to state 63 ]
  ! EQ              [ shift and go to state 74 ]
  ! NEQ             [ shift and go to state 78 ]
  ! >               [ shift and go to state 75 ]
  ! <               [ shift and go to state 67 ]
  ! LE              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 76 ]


state 106

    (66) bin_expression -> expression LE expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               reduce using rule 66 (bin_expression -> expression LE expression .)
    |               reduce using rule 66 (bin_expression -> expression LE expression .)
    &               reduce using rule 66 (bin_expression -> expression LE expression .)
    ^               reduce using rule 66 (bin_expression -> expression LE expression .)
    AND             reduce using rule 66 (bin_expression -> expression LE expression .)
    OR              reduce using rule 66 (bin_expression -> expression LE expression .)
    EQ              reduce using rule 66 (bin_expression -> expression LE expression .)
    NEQ             reduce using rule 66 (bin_expression -> expression LE expression .)
    >               reduce using rule 66 (bin_expression -> expression LE expression .)
    <               reduce using rule 66 (bin_expression -> expression LE expression .)
    LE              reduce using rule 66 (bin_expression -> expression LE expression .)
    GE              reduce using rule 66 (bin_expression -> expression LE expression .)
    ,               reduce using rule 66 (bin_expression -> expression LE expression .)
    )               reduce using rule 66 (bin_expression -> expression LE expression .)
    +               shift and go to state 69
    -               shift and go to state 71
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65
    SHL             shift and go to state 68
    SHR             shift and go to state 63

  ! +               [ reduce using rule 66 (bin_expression -> expression LE expression .) ]
  ! -               [ reduce using rule 66 (bin_expression -> expression LE expression .) ]
  ! *               [ reduce using rule 66 (bin_expression -> expression LE expression .) ]
  ! /               [ reduce using rule 66 (bin_expression -> expression LE expression .) ]
  ! %               [ reduce using rule 66 (bin_expression -> expression LE expression .) ]
  ! SHL             [ reduce using rule 66 (bin_expression -> expression LE expression .) ]
  ! SHR             [ reduce using rule 66 (bin_expression -> expression LE expression .) ]
  ! |               [ shift and go to state 79 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 80 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 73 ]
  ! EQ              [ shift and go to state 74 ]
  ! NEQ             [ shift and go to state 78 ]
  ! >               [ shift and go to state 75 ]
  ! <               [ shift and go to state 67 ]
  ! LE              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 76 ]


state 107

    (54) bin_expression -> expression % expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               reduce using rule 54 (bin_expression -> expression % expression .)
    +               reduce using rule 54 (bin_expression -> expression % expression .)
    -               reduce using rule 54 (bin_expression -> expression % expression .)
    *               reduce using rule 54 (bin_expression -> expression % expression .)
    /               reduce using rule 54 (bin_expression -> expression % expression .)
    %               reduce using rule 54 (bin_expression -> expression % expression .)
    |               reduce using rule 54 (bin_expression -> expression % expression .)
    &               reduce using rule 54 (bin_expression -> expression % expression .)
    ^               reduce using rule 54 (bin_expression -> expression % expression .)
    AND             reduce using rule 54 (bin_expression -> expression % expression .)
    OR              reduce using rule 54 (bin_expression -> expression % expression .)
    SHL             reduce using rule 54 (bin_expression -> expression % expression .)
    SHR             reduce using rule 54 (bin_expression -> expression % expression .)
    EQ              reduce using rule 54 (bin_expression -> expression % expression .)
    NEQ             reduce using rule 54 (bin_expression -> expression % expression .)
    >               reduce using rule 54 (bin_expression -> expression % expression .)
    <               reduce using rule 54 (bin_expression -> expression % expression .)
    LE              reduce using rule 54 (bin_expression -> expression % expression .)
    GE              reduce using rule 54 (bin_expression -> expression % expression .)
    ,               reduce using rule 54 (bin_expression -> expression % expression .)
    )               reduce using rule 54 (bin_expression -> expression % expression .)

  ! +               [ shift and go to state 69 ]
  ! -               [ shift and go to state 71 ]
  ! *               [ shift and go to state 70 ]
  ! /               [ shift and go to state 72 ]
  ! %               [ shift and go to state 65 ]
  ! |               [ shift and go to state 79 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 80 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 73 ]
  ! SHL             [ shift and go to state 68 ]
  ! SHR             [ shift and go to state 63 ]
  ! EQ              [ shift and go to state 74 ]
  ! NEQ             [ shift and go to state 78 ]
  ! >               [ shift and go to state 75 ]
  ! <               [ shift and go to state 67 ]
  ! LE              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 76 ]


state 108

    (56) bin_expression -> expression & expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               reduce using rule 56 (bin_expression -> expression & expression .)
    |               reduce using rule 56 (bin_expression -> expression & expression .)
    &               reduce using rule 56 (bin_expression -> expression & expression .)
    ^               reduce using rule 56 (bin_expression -> expression & expression .)
    AND             reduce using rule 56 (bin_expression -> expression & expression .)
    OR              reduce using rule 56 (bin_expression -> expression & expression .)
    ,               reduce using rule 56 (bin_expression -> expression & expression .)
    )               reduce using rule 56 (bin_expression -> expression & expression .)
    +               shift and go to state 69
    -               shift and go to state 71
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65
    SHL             shift and go to state 68
    SHR             shift and go to state 63
    EQ              shift and go to state 74
    NEQ             shift and go to state 78
    >               shift and go to state 75
    <               shift and go to state 67
    LE              shift and go to state 64
    GE              shift and go to state 76

  ! +               [ reduce using rule 56 (bin_expression -> expression & expression .) ]
  ! -               [ reduce using rule 56 (bin_expression -> expression & expression .) ]
  ! *               [ reduce using rule 56 (bin_expression -> expression & expression .) ]
  ! /               [ reduce using rule 56 (bin_expression -> expression & expression .) ]
  ! %               [ reduce using rule 56 (bin_expression -> expression & expression .) ]
  ! SHL             [ reduce using rule 56 (bin_expression -> expression & expression .) ]
  ! SHR             [ reduce using rule 56 (bin_expression -> expression & expression .) ]
  ! EQ              [ reduce using rule 56 (bin_expression -> expression & expression .) ]
  ! NEQ             [ reduce using rule 56 (bin_expression -> expression & expression .) ]
  ! >               [ reduce using rule 56 (bin_expression -> expression & expression .) ]
  ! <               [ reduce using rule 56 (bin_expression -> expression & expression .) ]
  ! LE              [ reduce using rule 56 (bin_expression -> expression & expression .) ]
  ! GE              [ reduce using rule 56 (bin_expression -> expression & expression .) ]
  ! |               [ shift and go to state 79 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 80 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 73 ]


state 109

    (65) bin_expression -> expression < expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               reduce using rule 65 (bin_expression -> expression < expression .)
    |               reduce using rule 65 (bin_expression -> expression < expression .)
    &               reduce using rule 65 (bin_expression -> expression < expression .)
    ^               reduce using rule 65 (bin_expression -> expression < expression .)
    AND             reduce using rule 65 (bin_expression -> expression < expression .)
    OR              reduce using rule 65 (bin_expression -> expression < expression .)
    EQ              reduce using rule 65 (bin_expression -> expression < expression .)
    NEQ             reduce using rule 65 (bin_expression -> expression < expression .)
    >               reduce using rule 65 (bin_expression -> expression < expression .)
    <               reduce using rule 65 (bin_expression -> expression < expression .)
    LE              reduce using rule 65 (bin_expression -> expression < expression .)
    GE              reduce using rule 65 (bin_expression -> expression < expression .)
    ,               reduce using rule 65 (bin_expression -> expression < expression .)
    )               reduce using rule 65 (bin_expression -> expression < expression .)
    +               shift and go to state 69
    -               shift and go to state 71
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65
    SHL             shift and go to state 68
    SHR             shift and go to state 63

  ! +               [ reduce using rule 65 (bin_expression -> expression < expression .) ]
  ! -               [ reduce using rule 65 (bin_expression -> expression < expression .) ]
  ! *               [ reduce using rule 65 (bin_expression -> expression < expression .) ]
  ! /               [ reduce using rule 65 (bin_expression -> expression < expression .) ]
  ! %               [ reduce using rule 65 (bin_expression -> expression < expression .) ]
  ! SHL             [ reduce using rule 65 (bin_expression -> expression < expression .) ]
  ! SHR             [ reduce using rule 65 (bin_expression -> expression < expression .) ]
  ! |               [ shift and go to state 79 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 80 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 73 ]
  ! EQ              [ shift and go to state 74 ]
  ! NEQ             [ shift and go to state 78 ]
  ! >               [ shift and go to state 75 ]
  ! <               [ shift and go to state 67 ]
  ! LE              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 76 ]


state 110

    (60) bin_expression -> expression SHL expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               reduce using rule 60 (bin_expression -> expression SHL expression .)
    |               reduce using rule 60 (bin_expression -> expression SHL expression .)
    &               reduce using rule 60 (bin_expression -> expression SHL expression .)
    ^               reduce using rule 60 (bin_expression -> expression SHL expression .)
    AND             reduce using rule 60 (bin_expression -> expression SHL expression .)
    OR              reduce using rule 60 (bin_expression -> expression SHL expression .)
    SHL             reduce using rule 60 (bin_expression -> expression SHL expression .)
    SHR             reduce using rule 60 (bin_expression -> expression SHL expression .)
    EQ              reduce using rule 60 (bin_expression -> expression SHL expression .)
    NEQ             reduce using rule 60 (bin_expression -> expression SHL expression .)
    >               reduce using rule 60 (bin_expression -> expression SHL expression .)
    <               reduce using rule 60 (bin_expression -> expression SHL expression .)
    LE              reduce using rule 60 (bin_expression -> expression SHL expression .)
    GE              reduce using rule 60 (bin_expression -> expression SHL expression .)
    ,               reduce using rule 60 (bin_expression -> expression SHL expression .)
    )               reduce using rule 60 (bin_expression -> expression SHL expression .)
    +               shift and go to state 69
    -               shift and go to state 71
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65

  ! +               [ reduce using rule 60 (bin_expression -> expression SHL expression .) ]
  ! -               [ reduce using rule 60 (bin_expression -> expression SHL expression .) ]
  ! *               [ reduce using rule 60 (bin_expression -> expression SHL expression .) ]
  ! /               [ reduce using rule 60 (bin_expression -> expression SHL expression .) ]
  ! %               [ reduce using rule 60 (bin_expression -> expression SHL expression .) ]
  ! |               [ shift and go to state 79 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 80 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 73 ]
  ! SHL             [ shift and go to state 68 ]
  ! SHR             [ shift and go to state 63 ]
  ! EQ              [ shift and go to state 74 ]
  ! NEQ             [ shift and go to state 78 ]
  ! >               [ shift and go to state 75 ]
  ! <               [ shift and go to state 67 ]
  ! LE              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 76 ]


state 111

    (50) bin_expression -> expression + expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               reduce using rule 50 (bin_expression -> expression + expression .)
    +               reduce using rule 50 (bin_expression -> expression + expression .)
    -               reduce using rule 50 (bin_expression -> expression + expression .)
    |               reduce using rule 50 (bin_expression -> expression + expression .)
    &               reduce using rule 50 (bin_expression -> expression + expression .)
    ^               reduce using rule 50 (bin_expression -> expression + expression .)
    AND             reduce using rule 50 (bin_expression -> expression + expression .)
    OR              reduce using rule 50 (bin_expression -> expression + expression .)
    SHL             reduce using rule 50 (bin_expression -> expression + expression .)
    SHR             reduce using rule 50 (bin_expression -> expression + expression .)
    EQ              reduce using rule 50 (bin_expression -> expression + expression .)
    NEQ             reduce using rule 50 (bin_expression -> expression + expression .)
    >               reduce using rule 50 (bin_expression -> expression + expression .)
    <               reduce using rule 50 (bin_expression -> expression + expression .)
    LE              reduce using rule 50 (bin_expression -> expression + expression .)
    GE              reduce using rule 50 (bin_expression -> expression + expression .)
    ,               reduce using rule 50 (bin_expression -> expression + expression .)
    )               reduce using rule 50 (bin_expression -> expression + expression .)
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65

  ! *               [ reduce using rule 50 (bin_expression -> expression + expression .) ]
  ! /               [ reduce using rule 50 (bin_expression -> expression + expression .) ]
  ! %               [ reduce using rule 50 (bin_expression -> expression + expression .) ]
  ! +               [ shift and go to state 69 ]
  ! -               [ shift and go to state 71 ]
  ! |               [ shift and go to state 79 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 80 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 73 ]
  ! SHL             [ shift and go to state 68 ]
  ! SHR             [ shift and go to state 63 ]
  ! EQ              [ shift and go to state 74 ]
  ! NEQ             [ shift and go to state 78 ]
  ! >               [ shift and go to state 75 ]
  ! <               [ shift and go to state 67 ]
  ! LE              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 76 ]


state 112

    (52) bin_expression -> expression * expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               reduce using rule 52 (bin_expression -> expression * expression .)
    +               reduce using rule 52 (bin_expression -> expression * expression .)
    -               reduce using rule 52 (bin_expression -> expression * expression .)
    *               reduce using rule 52 (bin_expression -> expression * expression .)
    /               reduce using rule 52 (bin_expression -> expression * expression .)
    %               reduce using rule 52 (bin_expression -> expression * expression .)
    |               reduce using rule 52 (bin_expression -> expression * expression .)
    &               reduce using rule 52 (bin_expression -> expression * expression .)
    ^               reduce using rule 52 (bin_expression -> expression * expression .)
    AND             reduce using rule 52 (bin_expression -> expression * expression .)
    OR              reduce using rule 52 (bin_expression -> expression * expression .)
    SHL             reduce using rule 52 (bin_expression -> expression * expression .)
    SHR             reduce using rule 52 (bin_expression -> expression * expression .)
    EQ              reduce using rule 52 (bin_expression -> expression * expression .)
    NEQ             reduce using rule 52 (bin_expression -> expression * expression .)
    >               reduce using rule 52 (bin_expression -> expression * expression .)
    <               reduce using rule 52 (bin_expression -> expression * expression .)
    LE              reduce using rule 52 (bin_expression -> expression * expression .)
    GE              reduce using rule 52 (bin_expression -> expression * expression .)
    ,               reduce using rule 52 (bin_expression -> expression * expression .)
    )               reduce using rule 52 (bin_expression -> expression * expression .)

  ! +               [ shift and go to state 69 ]
  ! -               [ shift and go to state 71 ]
  ! *               [ shift and go to state 70 ]
  ! /               [ shift and go to state 72 ]
  ! %               [ shift and go to state 65 ]
  ! |               [ shift and go to state 79 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 80 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 73 ]
  ! SHL             [ shift and go to state 68 ]
  ! SHR             [ shift and go to state 63 ]
  ! EQ              [ shift and go to state 74 ]
  ! NEQ             [ shift and go to state 78 ]
  ! >               [ shift and go to state 75 ]
  ! <               [ shift and go to state 67 ]
  ! LE              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 76 ]


state 113

    (51) bin_expression -> expression - expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               reduce using rule 51 (bin_expression -> expression - expression .)
    +               reduce using rule 51 (bin_expression -> expression - expression .)
    -               reduce using rule 51 (bin_expression -> expression - expression .)
    |               reduce using rule 51 (bin_expression -> expression - expression .)
    &               reduce using rule 51 (bin_expression -> expression - expression .)
    ^               reduce using rule 51 (bin_expression -> expression - expression .)
    AND             reduce using rule 51 (bin_expression -> expression - expression .)
    OR              reduce using rule 51 (bin_expression -> expression - expression .)
    SHL             reduce using rule 51 (bin_expression -> expression - expression .)
    SHR             reduce using rule 51 (bin_expression -> expression - expression .)
    EQ              reduce using rule 51 (bin_expression -> expression - expression .)
    NEQ             reduce using rule 51 (bin_expression -> expression - expression .)
    >               reduce using rule 51 (bin_expression -> expression - expression .)
    <               reduce using rule 51 (bin_expression -> expression - expression .)
    LE              reduce using rule 51 (bin_expression -> expression - expression .)
    GE              reduce using rule 51 (bin_expression -> expression - expression .)
    ,               reduce using rule 51 (bin_expression -> expression - expression .)
    )               reduce using rule 51 (bin_expression -> expression - expression .)
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65

  ! *               [ reduce using rule 51 (bin_expression -> expression - expression .) ]
  ! /               [ reduce using rule 51 (bin_expression -> expression - expression .) ]
  ! %               [ reduce using rule 51 (bin_expression -> expression - expression .) ]
  ! +               [ shift and go to state 69 ]
  ! -               [ shift and go to state 71 ]
  ! |               [ shift and go to state 79 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 80 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 73 ]
  ! SHL             [ shift and go to state 68 ]
  ! SHR             [ shift and go to state 63 ]
  ! EQ              [ shift and go to state 74 ]
  ! NEQ             [ shift and go to state 78 ]
  ! >               [ shift and go to state 75 ]
  ! <               [ shift and go to state 67 ]
  ! LE              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 76 ]


state 114

    (53) bin_expression -> expression / expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               reduce using rule 53 (bin_expression -> expression / expression .)
    +               reduce using rule 53 (bin_expression -> expression / expression .)
    -               reduce using rule 53 (bin_expression -> expression / expression .)
    *               reduce using rule 53 (bin_expression -> expression / expression .)
    /               reduce using rule 53 (bin_expression -> expression / expression .)
    %               reduce using rule 53 (bin_expression -> expression / expression .)
    |               reduce using rule 53 (bin_expression -> expression / expression .)
    &               reduce using rule 53 (bin_expression -> expression / expression .)
    ^               reduce using rule 53 (bin_expression -> expression / expression .)
    AND             reduce using rule 53 (bin_expression -> expression / expression .)
    OR              reduce using rule 53 (bin_expression -> expression / expression .)
    SHL             reduce using rule 53 (bin_expression -> expression / expression .)
    SHR             reduce using rule 53 (bin_expression -> expression / expression .)
    EQ              reduce using rule 53 (bin_expression -> expression / expression .)
    NEQ             reduce using rule 53 (bin_expression -> expression / expression .)
    >               reduce using rule 53 (bin_expression -> expression / expression .)
    <               reduce using rule 53 (bin_expression -> expression / expression .)
    LE              reduce using rule 53 (bin_expression -> expression / expression .)
    GE              reduce using rule 53 (bin_expression -> expression / expression .)
    ,               reduce using rule 53 (bin_expression -> expression / expression .)
    )               reduce using rule 53 (bin_expression -> expression / expression .)

  ! +               [ shift and go to state 69 ]
  ! -               [ shift and go to state 71 ]
  ! *               [ shift and go to state 70 ]
  ! /               [ shift and go to state 72 ]
  ! %               [ shift and go to state 65 ]
  ! |               [ shift and go to state 79 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 80 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 73 ]
  ! SHL             [ shift and go to state 68 ]
  ! SHR             [ shift and go to state 63 ]
  ! EQ              [ shift and go to state 74 ]
  ! NEQ             [ shift and go to state 78 ]
  ! >               [ shift and go to state 75 ]
  ! <               [ shift and go to state 67 ]
  ! LE              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 76 ]


state 115

    (59) bin_expression -> expression OR expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               reduce using rule 59 (bin_expression -> expression OR expression .)
    OR              reduce using rule 59 (bin_expression -> expression OR expression .)
    ,               reduce using rule 59 (bin_expression -> expression OR expression .)
    )               reduce using rule 59 (bin_expression -> expression OR expression .)
    +               shift and go to state 69
    -               shift and go to state 71
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65
    |               shift and go to state 79
    &               shift and go to state 66
    ^               shift and go to state 80
    AND             shift and go to state 62
    SHL             shift and go to state 68
    SHR             shift and go to state 63
    EQ              shift and go to state 74
    NEQ             shift and go to state 78
    >               shift and go to state 75
    <               shift and go to state 67
    LE              shift and go to state 64
    GE              shift and go to state 76

  ! +               [ reduce using rule 59 (bin_expression -> expression OR expression .) ]
  ! -               [ reduce using rule 59 (bin_expression -> expression OR expression .) ]
  ! *               [ reduce using rule 59 (bin_expression -> expression OR expression .) ]
  ! /               [ reduce using rule 59 (bin_expression -> expression OR expression .) ]
  ! %               [ reduce using rule 59 (bin_expression -> expression OR expression .) ]
  ! |               [ reduce using rule 59 (bin_expression -> expression OR expression .) ]
  ! &               [ reduce using rule 59 (bin_expression -> expression OR expression .) ]
  ! ^               [ reduce using rule 59 (bin_expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 59 (bin_expression -> expression OR expression .) ]
  ! SHL             [ reduce using rule 59 (bin_expression -> expression OR expression .) ]
  ! SHR             [ reduce using rule 59 (bin_expression -> expression OR expression .) ]
  ! EQ              [ reduce using rule 59 (bin_expression -> expression OR expression .) ]
  ! NEQ             [ reduce using rule 59 (bin_expression -> expression OR expression .) ]
  ! >               [ reduce using rule 59 (bin_expression -> expression OR expression .) ]
  ! <               [ reduce using rule 59 (bin_expression -> expression OR expression .) ]
  ! LE              [ reduce using rule 59 (bin_expression -> expression OR expression .) ]
  ! GE              [ reduce using rule 59 (bin_expression -> expression OR expression .) ]
  ! OR              [ shift and go to state 73 ]


state 116

    (62) bin_expression -> expression EQ expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               reduce using rule 62 (bin_expression -> expression EQ expression .)
    |               reduce using rule 62 (bin_expression -> expression EQ expression .)
    &               reduce using rule 62 (bin_expression -> expression EQ expression .)
    ^               reduce using rule 62 (bin_expression -> expression EQ expression .)
    AND             reduce using rule 62 (bin_expression -> expression EQ expression .)
    OR              reduce using rule 62 (bin_expression -> expression EQ expression .)
    EQ              reduce using rule 62 (bin_expression -> expression EQ expression .)
    NEQ             reduce using rule 62 (bin_expression -> expression EQ expression .)
    >               reduce using rule 62 (bin_expression -> expression EQ expression .)
    <               reduce using rule 62 (bin_expression -> expression EQ expression .)
    LE              reduce using rule 62 (bin_expression -> expression EQ expression .)
    GE              reduce using rule 62 (bin_expression -> expression EQ expression .)
    ,               reduce using rule 62 (bin_expression -> expression EQ expression .)
    )               reduce using rule 62 (bin_expression -> expression EQ expression .)
    +               shift and go to state 69
    -               shift and go to state 71
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65
    SHL             shift and go to state 68
    SHR             shift and go to state 63

  ! +               [ reduce using rule 62 (bin_expression -> expression EQ expression .) ]
  ! -               [ reduce using rule 62 (bin_expression -> expression EQ expression .) ]
  ! *               [ reduce using rule 62 (bin_expression -> expression EQ expression .) ]
  ! /               [ reduce using rule 62 (bin_expression -> expression EQ expression .) ]
  ! %               [ reduce using rule 62 (bin_expression -> expression EQ expression .) ]
  ! SHL             [ reduce using rule 62 (bin_expression -> expression EQ expression .) ]
  ! SHR             [ reduce using rule 62 (bin_expression -> expression EQ expression .) ]
  ! |               [ shift and go to state 79 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 80 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 73 ]
  ! EQ              [ shift and go to state 74 ]
  ! NEQ             [ shift and go to state 78 ]
  ! >               [ shift and go to state 75 ]
  ! <               [ shift and go to state 67 ]
  ! LE              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 76 ]


state 117

    (64) bin_expression -> expression > expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               reduce using rule 64 (bin_expression -> expression > expression .)
    |               reduce using rule 64 (bin_expression -> expression > expression .)
    &               reduce using rule 64 (bin_expression -> expression > expression .)
    ^               reduce using rule 64 (bin_expression -> expression > expression .)
    AND             reduce using rule 64 (bin_expression -> expression > expression .)
    OR              reduce using rule 64 (bin_expression -> expression > expression .)
    EQ              reduce using rule 64 (bin_expression -> expression > expression .)
    NEQ             reduce using rule 64 (bin_expression -> expression > expression .)
    >               reduce using rule 64 (bin_expression -> expression > expression .)
    <               reduce using rule 64 (bin_expression -> expression > expression .)
    LE              reduce using rule 64 (bin_expression -> expression > expression .)
    GE              reduce using rule 64 (bin_expression -> expression > expression .)
    ,               reduce using rule 64 (bin_expression -> expression > expression .)
    )               reduce using rule 64 (bin_expression -> expression > expression .)
    +               shift and go to state 69
    -               shift and go to state 71
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65
    SHL             shift and go to state 68
    SHR             shift and go to state 63

  ! +               [ reduce using rule 64 (bin_expression -> expression > expression .) ]
  ! -               [ reduce using rule 64 (bin_expression -> expression > expression .) ]
  ! *               [ reduce using rule 64 (bin_expression -> expression > expression .) ]
  ! /               [ reduce using rule 64 (bin_expression -> expression > expression .) ]
  ! %               [ reduce using rule 64 (bin_expression -> expression > expression .) ]
  ! SHL             [ reduce using rule 64 (bin_expression -> expression > expression .) ]
  ! SHR             [ reduce using rule 64 (bin_expression -> expression > expression .) ]
  ! |               [ shift and go to state 79 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 80 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 73 ]
  ! EQ              [ shift and go to state 74 ]
  ! NEQ             [ shift and go to state 78 ]
  ! >               [ shift and go to state 75 ]
  ! <               [ shift and go to state 67 ]
  ! LE              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 76 ]


state 118

    (67) bin_expression -> expression GE expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               reduce using rule 67 (bin_expression -> expression GE expression .)
    |               reduce using rule 67 (bin_expression -> expression GE expression .)
    &               reduce using rule 67 (bin_expression -> expression GE expression .)
    ^               reduce using rule 67 (bin_expression -> expression GE expression .)
    AND             reduce using rule 67 (bin_expression -> expression GE expression .)
    OR              reduce using rule 67 (bin_expression -> expression GE expression .)
    EQ              reduce using rule 67 (bin_expression -> expression GE expression .)
    NEQ             reduce using rule 67 (bin_expression -> expression GE expression .)
    >               reduce using rule 67 (bin_expression -> expression GE expression .)
    <               reduce using rule 67 (bin_expression -> expression GE expression .)
    LE              reduce using rule 67 (bin_expression -> expression GE expression .)
    GE              reduce using rule 67 (bin_expression -> expression GE expression .)
    ,               reduce using rule 67 (bin_expression -> expression GE expression .)
    )               reduce using rule 67 (bin_expression -> expression GE expression .)
    +               shift and go to state 69
    -               shift and go to state 71
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65
    SHL             shift and go to state 68
    SHR             shift and go to state 63

  ! +               [ reduce using rule 67 (bin_expression -> expression GE expression .) ]
  ! -               [ reduce using rule 67 (bin_expression -> expression GE expression .) ]
  ! *               [ reduce using rule 67 (bin_expression -> expression GE expression .) ]
  ! /               [ reduce using rule 67 (bin_expression -> expression GE expression .) ]
  ! %               [ reduce using rule 67 (bin_expression -> expression GE expression .) ]
  ! SHL             [ reduce using rule 67 (bin_expression -> expression GE expression .) ]
  ! SHR             [ reduce using rule 67 (bin_expression -> expression GE expression .) ]
  ! |               [ shift and go to state 79 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 80 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 73 ]
  ! EQ              [ shift and go to state 74 ]
  ! NEQ             [ shift and go to state 78 ]
  ! >               [ shift and go to state 75 ]
  ! <               [ shift and go to state 67 ]
  ! LE              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 76 ]


state 119

    (63) bin_expression -> expression NEQ expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               reduce using rule 63 (bin_expression -> expression NEQ expression .)
    |               reduce using rule 63 (bin_expression -> expression NEQ expression .)
    &               reduce using rule 63 (bin_expression -> expression NEQ expression .)
    ^               reduce using rule 63 (bin_expression -> expression NEQ expression .)
    AND             reduce using rule 63 (bin_expression -> expression NEQ expression .)
    OR              reduce using rule 63 (bin_expression -> expression NEQ expression .)
    EQ              reduce using rule 63 (bin_expression -> expression NEQ expression .)
    NEQ             reduce using rule 63 (bin_expression -> expression NEQ expression .)
    >               reduce using rule 63 (bin_expression -> expression NEQ expression .)
    <               reduce using rule 63 (bin_expression -> expression NEQ expression .)
    LE              reduce using rule 63 (bin_expression -> expression NEQ expression .)
    GE              reduce using rule 63 (bin_expression -> expression NEQ expression .)
    ,               reduce using rule 63 (bin_expression -> expression NEQ expression .)
    )               reduce using rule 63 (bin_expression -> expression NEQ expression .)
    +               shift and go to state 69
    -               shift and go to state 71
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65
    SHL             shift and go to state 68
    SHR             shift and go to state 63

  ! +               [ reduce using rule 63 (bin_expression -> expression NEQ expression .) ]
  ! -               [ reduce using rule 63 (bin_expression -> expression NEQ expression .) ]
  ! *               [ reduce using rule 63 (bin_expression -> expression NEQ expression .) ]
  ! /               [ reduce using rule 63 (bin_expression -> expression NEQ expression .) ]
  ! %               [ reduce using rule 63 (bin_expression -> expression NEQ expression .) ]
  ! SHL             [ reduce using rule 63 (bin_expression -> expression NEQ expression .) ]
  ! SHR             [ reduce using rule 63 (bin_expression -> expression NEQ expression .) ]
  ! |               [ shift and go to state 79 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 80 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 73 ]
  ! EQ              [ shift and go to state 74 ]
  ! NEQ             [ shift and go to state 78 ]
  ! >               [ shift and go to state 75 ]
  ! <               [ shift and go to state 67 ]
  ! LE              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 76 ]


state 120

    (55) bin_expression -> expression | expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               reduce using rule 55 (bin_expression -> expression | expression .)
    |               reduce using rule 55 (bin_expression -> expression | expression .)
    AND             reduce using rule 55 (bin_expression -> expression | expression .)
    OR              reduce using rule 55 (bin_expression -> expression | expression .)
    ,               reduce using rule 55 (bin_expression -> expression | expression .)
    )               reduce using rule 55 (bin_expression -> expression | expression .)
    +               shift and go to state 69
    -               shift and go to state 71
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65
    &               shift and go to state 66
    ^               shift and go to state 80
    SHL             shift and go to state 68
    SHR             shift and go to state 63
    EQ              shift and go to state 74
    NEQ             shift and go to state 78
    >               shift and go to state 75
    <               shift and go to state 67
    LE              shift and go to state 64
    GE              shift and go to state 76

  ! +               [ reduce using rule 55 (bin_expression -> expression | expression .) ]
  ! -               [ reduce using rule 55 (bin_expression -> expression | expression .) ]
  ! *               [ reduce using rule 55 (bin_expression -> expression | expression .) ]
  ! /               [ reduce using rule 55 (bin_expression -> expression | expression .) ]
  ! %               [ reduce using rule 55 (bin_expression -> expression | expression .) ]
  ! &               [ reduce using rule 55 (bin_expression -> expression | expression .) ]
  ! ^               [ reduce using rule 55 (bin_expression -> expression | expression .) ]
  ! SHL             [ reduce using rule 55 (bin_expression -> expression | expression .) ]
  ! SHR             [ reduce using rule 55 (bin_expression -> expression | expression .) ]
  ! EQ              [ reduce using rule 55 (bin_expression -> expression | expression .) ]
  ! NEQ             [ reduce using rule 55 (bin_expression -> expression | expression .) ]
  ! >               [ reduce using rule 55 (bin_expression -> expression | expression .) ]
  ! <               [ reduce using rule 55 (bin_expression -> expression | expression .) ]
  ! LE              [ reduce using rule 55 (bin_expression -> expression | expression .) ]
  ! GE              [ reduce using rule 55 (bin_expression -> expression | expression .) ]
  ! |               [ shift and go to state 79 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 73 ]


state 121

    (57) bin_expression -> expression ^ expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               reduce using rule 57 (bin_expression -> expression ^ expression .)
    |               reduce using rule 57 (bin_expression -> expression ^ expression .)
    ^               reduce using rule 57 (bin_expression -> expression ^ expression .)
    AND             reduce using rule 57 (bin_expression -> expression ^ expression .)
    OR              reduce using rule 57 (bin_expression -> expression ^ expression .)
    ,               reduce using rule 57 (bin_expression -> expression ^ expression .)
    )               reduce using rule 57 (bin_expression -> expression ^ expression .)
    +               shift and go to state 69
    -               shift and go to state 71
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65
    &               shift and go to state 66
    SHL             shift and go to state 68
    SHR             shift and go to state 63
    EQ              shift and go to state 74
    NEQ             shift and go to state 78
    >               shift and go to state 75
    <               shift and go to state 67
    LE              shift and go to state 64
    GE              shift and go to state 76

  ! +               [ reduce using rule 57 (bin_expression -> expression ^ expression .) ]
  ! -               [ reduce using rule 57 (bin_expression -> expression ^ expression .) ]
  ! *               [ reduce using rule 57 (bin_expression -> expression ^ expression .) ]
  ! /               [ reduce using rule 57 (bin_expression -> expression ^ expression .) ]
  ! %               [ reduce using rule 57 (bin_expression -> expression ^ expression .) ]
  ! &               [ reduce using rule 57 (bin_expression -> expression ^ expression .) ]
  ! SHL             [ reduce using rule 57 (bin_expression -> expression ^ expression .) ]
  ! SHR             [ reduce using rule 57 (bin_expression -> expression ^ expression .) ]
  ! EQ              [ reduce using rule 57 (bin_expression -> expression ^ expression .) ]
  ! NEQ             [ reduce using rule 57 (bin_expression -> expression ^ expression .) ]
  ! >               [ reduce using rule 57 (bin_expression -> expression ^ expression .) ]
  ! <               [ reduce using rule 57 (bin_expression -> expression ^ expression .) ]
  ! LE              [ reduce using rule 57 (bin_expression -> expression ^ expression .) ]
  ! GE              [ reduce using rule 57 (bin_expression -> expression ^ expression .) ]
  ! |               [ shift and go to state 79 ]
  ! ^               [ shift and go to state 80 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 73 ]


state 122

    (6) inits -> inits , init .

    ;               reduce using rule 6 (inits -> inits , init .)
    ,               reduce using rule 6 (inits -> inits , init .)


state 123

    (8) init -> ID . = expression

    =               shift and go to state 84


state 124

    (77) args_list_or_empty -> args_list .
    (79) args_list -> args_list . , arg

    )               reduce using rule 77 (args_list_or_empty -> args_list .)
    ,               shift and go to state 139


state 125

    (76) fundef -> TYPE ID ( args_list_or_empty . ) compound_instr

    )               shift and go to state 140


state 126

    (80) args_list -> arg .

    ,               reduce using rule 80 (args_list -> arg .)
    )               reduce using rule 80 (args_list -> arg .)


state 127

    (81) arg -> TYPE . ID

    ID              shift and go to state 141


state 128

    (8) init -> ID = expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ;               reduce using rule 8 (init -> ID = expression .)
    ,               reduce using rule 8 (init -> ID = expression .)
    +               shift and go to state 69
    -               shift and go to state 71
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65
    |               shift and go to state 79
    &               shift and go to state 66
    ^               shift and go to state 80
    AND             shift and go to state 62
    OR              shift and go to state 73
    SHL             shift and go to state 68
    SHR             shift and go to state 63
    EQ              shift and go to state 74
    NEQ             shift and go to state 78
    >               shift and go to state 75
    <               shift and go to state 67
    LE              shift and go to state 64
    GE              shift and go to state 76


state 129

    (28) choice_instr -> IF ( condition ) . instruction
    (29) choice_instr -> IF ( condition ) . instruction ELSE instruction
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expr_list ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { declarations instructions_opt }
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    PRINT           shift and go to state 15
    ID              shift and go to state 31
    IF              shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 25
    RETURN          shift and go to state 12
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 38
    {               shift and go to state 39
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    return_instr                   shift and go to state 18
    const                          shift and go to state 19
    assignment                     shift and go to state 27
    instruction                    shift and go to state 142
    compound_instr                 shift and go to state 30
    continue_instr                 shift and go to state 21
    labeled_instr                  shift and go to state 28
    print_instr                    shift and go to state 37
    choice_instr                   shift and go to state 13
    repeat_instr                   shift and go to state 17
    bin_expression                 shift and go to state 23
    break_instr                    shift and go to state 33
    while_instr                    shift and go to state 22
    expression                     shift and go to state 40

state 130

    (30) choice_instr -> IF ( error ) . instruction
    (31) choice_instr -> IF ( error ) . instruction ELSE instruction
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expr_list ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { declarations instructions_opt }
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    PRINT           shift and go to state 15
    ID              shift and go to state 31
    IF              shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 25
    RETURN          shift and go to state 12
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 38
    {               shift and go to state 39
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    return_instr                   shift and go to state 18
    const                          shift and go to state 19
    assignment                     shift and go to state 27
    instruction                    shift and go to state 143
    compound_instr                 shift and go to state 30
    continue_instr                 shift and go to state 21
    while_instr                    shift and go to state 22
    print_instr                    shift and go to state 37
    choice_instr                   shift and go to state 13
    bin_expression                 shift and go to state 23
    break_instr                    shift and go to state 33
    labeled_instr                  shift and go to state 28
    expression                     shift and go to state 40
    repeat_instr                   shift and go to state 17

state 131

    (70) expr_list -> expr_list , expression .
    (50) bin_expression -> expression . + expression
    (51) bin_expression -> expression . - expression
    (52) bin_expression -> expression . * expression
    (53) bin_expression -> expression . / expression
    (54) bin_expression -> expression . % expression
    (55) bin_expression -> expression . | expression
    (56) bin_expression -> expression . & expression
    (57) bin_expression -> expression . ^ expression
    (58) bin_expression -> expression . AND expression
    (59) bin_expression -> expression . OR expression
    (60) bin_expression -> expression . SHL expression
    (61) bin_expression -> expression . SHR expression
    (62) bin_expression -> expression . EQ expression
    (63) bin_expression -> expression . NEQ expression
    (64) bin_expression -> expression . > expression
    (65) bin_expression -> expression . < expression
    (66) bin_expression -> expression . LE expression
    (67) bin_expression -> expression . GE expression

    ,               reduce using rule 70 (expr_list -> expr_list , expression .)
    )               reduce using rule 70 (expr_list -> expr_list , expression .)
    ;               reduce using rule 70 (expr_list -> expr_list , expression .)
    +               shift and go to state 69
    -               shift and go to state 71
    *               shift and go to state 70
    /               shift and go to state 72
    %               shift and go to state 65
    |               shift and go to state 79
    &               shift and go to state 66
    ^               shift and go to state 80
    AND             shift and go to state 62
    OR              shift and go to state 73
    SHL             shift and go to state 68
    SHR             shift and go to state 63
    EQ              shift and go to state 74
    NEQ             shift and go to state 78
    >               shift and go to state 75
    <               shift and go to state 67
    LE              shift and go to state 64
    GE              shift and go to state 76


state 132

    (32) while_instr -> WHILE ( condition ) . instruction
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expr_list ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { declarations instructions_opt }
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    PRINT           shift and go to state 15
    ID              shift and go to state 31
    IF              shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 25
    RETURN          shift and go to state 12
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 38
    {               shift and go to state 39
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    return_instr                   shift and go to state 18
    const                          shift and go to state 19
    assignment                     shift and go to state 27
    instruction                    shift and go to state 144
    compound_instr                 shift and go to state 30
    continue_instr                 shift and go to state 21
    labeled_instr                  shift and go to state 28
    print_instr                    shift and go to state 37
    choice_instr                   shift and go to state 13
    repeat_instr                   shift and go to state 17
    bin_expression                 shift and go to state 23
    break_instr                    shift and go to state 33
    while_instr                    shift and go to state 22
    expression                     shift and go to state 40

state 133

    (33) while_instr -> WHILE ( error ) . instruction
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expr_list ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { declarations instructions_opt }
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    PRINT           shift and go to state 15
    ID              shift and go to state 31
    IF              shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 25
    RETURN          shift and go to state 12
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 38
    {               shift and go to state 39
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    return_instr                   shift and go to state 18
    const                          shift and go to state 19
    assignment                     shift and go to state 27
    instruction                    shift and go to state 145
    compound_instr                 shift and go to state 30
    continue_instr                 shift and go to state 21
    while_instr                    shift and go to state 22
    print_instr                    shift and go to state 37
    choice_instr                   shift and go to state 13
    bin_expression                 shift and go to state 23
    break_instr                    shift and go to state 33
    labeled_instr                  shift and go to state 28
    expression                     shift and go to state 40
    repeat_instr                   shift and go to state 17

state 134

    (34) repeat_instr -> REPEAT instructions UNTIL condition . ;

    ;               shift and go to state 146


state 135

    (48) expression -> ID ( expr_list_or_empty ) .

    ;               reduce using rule 48 (expression -> ID ( expr_list_or_empty ) .)
    +               reduce using rule 48 (expression -> ID ( expr_list_or_empty ) .)
    -               reduce using rule 48 (expression -> ID ( expr_list_or_empty ) .)
    *               reduce using rule 48 (expression -> ID ( expr_list_or_empty ) .)
    /               reduce using rule 48 (expression -> ID ( expr_list_or_empty ) .)
    %               reduce using rule 48 (expression -> ID ( expr_list_or_empty ) .)
    |               reduce using rule 48 (expression -> ID ( expr_list_or_empty ) .)
    &               reduce using rule 48 (expression -> ID ( expr_list_or_empty ) .)
    ^               reduce using rule 48 (expression -> ID ( expr_list_or_empty ) .)
    AND             reduce using rule 48 (expression -> ID ( expr_list_or_empty ) .)
    OR              reduce using rule 48 (expression -> ID ( expr_list_or_empty ) .)
    SHL             reduce using rule 48 (expression -> ID ( expr_list_or_empty ) .)
    SHR             reduce using rule 48 (expression -> ID ( expr_list_or_empty ) .)
    EQ              reduce using rule 48 (expression -> ID ( expr_list_or_empty ) .)
    NEQ             reduce using rule 48 (expression -> ID ( expr_list_or_empty ) .)
    >               reduce using rule 48 (expression -> ID ( expr_list_or_empty ) .)
    <               reduce using rule 48 (expression -> ID ( expr_list_or_empty ) .)
    LE              reduce using rule 48 (expression -> ID ( expr_list_or_empty ) .)
    GE              reduce using rule 48 (expression -> ID ( expr_list_or_empty ) .)
    ,               reduce using rule 48 (expression -> ID ( expr_list_or_empty ) .)
    )               reduce using rule 48 (expression -> ID ( expr_list_or_empty ) .)


state 136

    (49) expression -> ID ( error ) .

    ;               reduce using rule 49 (expression -> ID ( error ) .)
    +               reduce using rule 49 (expression -> ID ( error ) .)
    -               reduce using rule 49 (expression -> ID ( error ) .)
    *               reduce using rule 49 (expression -> ID ( error ) .)
    /               reduce using rule 49 (expression -> ID ( error ) .)
    %               reduce using rule 49 (expression -> ID ( error ) .)
    |               reduce using rule 49 (expression -> ID ( error ) .)
    &               reduce using rule 49 (expression -> ID ( error ) .)
    ^               reduce using rule 49 (expression -> ID ( error ) .)
    AND             reduce using rule 49 (expression -> ID ( error ) .)
    OR              reduce using rule 49 (expression -> ID ( error ) .)
    SHL             reduce using rule 49 (expression -> ID ( error ) .)
    SHR             reduce using rule 49 (expression -> ID ( error ) .)
    EQ              reduce using rule 49 (expression -> ID ( error ) .)
    NEQ             reduce using rule 49 (expression -> ID ( error ) .)
    >               reduce using rule 49 (expression -> ID ( error ) .)
    <               reduce using rule 49 (expression -> ID ( error ) .)
    LE              reduce using rule 49 (expression -> ID ( error ) .)
    GE              reduce using rule 49 (expression -> ID ( error ) .)
    ,               reduce using rule 49 (expression -> ID ( error ) .)
    )               reduce using rule 49 (expression -> ID ( error ) .)


state 137

    (27) assignment -> ID = expression ; .

    PRINT           reduce using rule 27 (assignment -> ID = expression ; .)
    ID              reduce using rule 27 (assignment -> ID = expression ; .)
    IF              reduce using rule 27 (assignment -> ID = expression ; .)
    WHILE           reduce using rule 27 (assignment -> ID = expression ; .)
    REPEAT          reduce using rule 27 (assignment -> ID = expression ; .)
    RETURN          reduce using rule 27 (assignment -> ID = expression ; .)
    BREAK           reduce using rule 27 (assignment -> ID = expression ; .)
    CONTINUE        reduce using rule 27 (assignment -> ID = expression ; .)
    {               reduce using rule 27 (assignment -> ID = expression ; .)
    (               reduce using rule 27 (assignment -> ID = expression ; .)
    INTEGER         reduce using rule 27 (assignment -> ID = expression ; .)
    FLOAT           reduce using rule 27 (assignment -> ID = expression ; .)
    STRING          reduce using rule 27 (assignment -> ID = expression ; .)
    $end            reduce using rule 27 (assignment -> ID = expression ; .)
    UNTIL           reduce using rule 27 (assignment -> ID = expression ; .)
    }               reduce using rule 27 (assignment -> ID = expression ; .)
    ELSE            reduce using rule 27 (assignment -> ID = expression ; .)


state 138

    (38) compound_instr -> { declarations instructions_opt } .

    PRINT           reduce using rule 38 (compound_instr -> { declarations instructions_opt } .)
    ID              reduce using rule 38 (compound_instr -> { declarations instructions_opt } .)
    IF              reduce using rule 38 (compound_instr -> { declarations instructions_opt } .)
    WHILE           reduce using rule 38 (compound_instr -> { declarations instructions_opt } .)
    REPEAT          reduce using rule 38 (compound_instr -> { declarations instructions_opt } .)
    RETURN          reduce using rule 38 (compound_instr -> { declarations instructions_opt } .)
    BREAK           reduce using rule 38 (compound_instr -> { declarations instructions_opt } .)
    CONTINUE        reduce using rule 38 (compound_instr -> { declarations instructions_opt } .)
    {               reduce using rule 38 (compound_instr -> { declarations instructions_opt } .)
    (               reduce using rule 38 (compound_instr -> { declarations instructions_opt } .)
    INTEGER         reduce using rule 38 (compound_instr -> { declarations instructions_opt } .)
    FLOAT           reduce using rule 38 (compound_instr -> { declarations instructions_opt } .)
    STRING          reduce using rule 38 (compound_instr -> { declarations instructions_opt } .)
    }               reduce using rule 38 (compound_instr -> { declarations instructions_opt } .)
    $end            reduce using rule 38 (compound_instr -> { declarations instructions_opt } .)
    UNTIL           reduce using rule 38 (compound_instr -> { declarations instructions_opt } .)
    ELSE            reduce using rule 38 (compound_instr -> { declarations instructions_opt } .)
    TYPE            reduce using rule 38 (compound_instr -> { declarations instructions_opt } .)


state 139

    (79) args_list -> args_list , . arg
    (81) arg -> . TYPE ID

    TYPE            shift and go to state 127

    arg                            shift and go to state 147

state 140

    (76) fundef -> TYPE ID ( args_list_or_empty ) . compound_instr
    (38) compound_instr -> . { declarations instructions_opt }

    {               shift and go to state 39

    compound_instr                 shift and go to state 148

state 141

    (81) arg -> TYPE ID .

    ,               reduce using rule 81 (arg -> TYPE ID .)
    )               reduce using rule 81 (arg -> TYPE ID .)


state 142

    (28) choice_instr -> IF ( condition ) instruction .
    (29) choice_instr -> IF ( condition ) instruction . ELSE instruction

    PRINT           reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    ID              reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    IF              reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    WHILE           reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    REPEAT          reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    RETURN          reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    BREAK           reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    CONTINUE        reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    {               reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    (               reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    INTEGER         reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    FLOAT           reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    STRING          reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    $end            reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    UNTIL           reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    }               reduce using rule 28 (choice_instr -> IF ( condition ) instruction .)
    ELSE            shift and go to state 149

  ! ELSE            [ reduce using rule 28 (choice_instr -> IF ( condition ) instruction .) ]


state 143

    (30) choice_instr -> IF ( error ) instruction .
    (31) choice_instr -> IF ( error ) instruction . ELSE instruction

    PRINT           reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    ID              reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    IF              reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    WHILE           reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    REPEAT          reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    RETURN          reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    BREAK           reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    CONTINUE        reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    {               reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    (               reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    INTEGER         reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    FLOAT           reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    STRING          reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    $end            reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    UNTIL           reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    }               reduce using rule 30 (choice_instr -> IF ( error ) instruction .)
    ELSE            shift and go to state 150

  ! ELSE            [ reduce using rule 30 (choice_instr -> IF ( error ) instruction .) ]


state 144

    (32) while_instr -> WHILE ( condition ) instruction .

    UNTIL           reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    PRINT           reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    ID              reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    IF              reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    WHILE           reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    REPEAT          reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    RETURN          reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    BREAK           reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    CONTINUE        reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    {               reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    (               reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    INTEGER         reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    FLOAT           reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    STRING          reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    }               reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    $end            reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)
    ELSE            reduce using rule 32 (while_instr -> WHILE ( condition ) instruction .)


state 145

    (33) while_instr -> WHILE ( error ) instruction .

    UNTIL           reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    PRINT           reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    ID              reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    IF              reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    WHILE           reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    REPEAT          reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    RETURN          reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    BREAK           reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    CONTINUE        reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    {               reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    (               reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    INTEGER         reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    FLOAT           reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    STRING          reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    }               reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    $end            reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)
    ELSE            reduce using rule 33 (while_instr -> WHILE ( error ) instruction .)


state 146

    (34) repeat_instr -> REPEAT instructions UNTIL condition ; .

    PRINT           reduce using rule 34 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    ID              reduce using rule 34 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    IF              reduce using rule 34 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    WHILE           reduce using rule 34 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    REPEAT          reduce using rule 34 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    RETURN          reduce using rule 34 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    BREAK           reduce using rule 34 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    CONTINUE        reduce using rule 34 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    {               reduce using rule 34 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    (               reduce using rule 34 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    INTEGER         reduce using rule 34 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    FLOAT           reduce using rule 34 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    STRING          reduce using rule 34 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    $end            reduce using rule 34 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    UNTIL           reduce using rule 34 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    }               reduce using rule 34 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    ELSE            reduce using rule 34 (repeat_instr -> REPEAT instructions UNTIL condition ; .)


state 147

    (79) args_list -> args_list , arg .

    ,               reduce using rule 79 (args_list -> args_list , arg .)
    )               reduce using rule 79 (args_list -> args_list , arg .)


state 148

    (76) fundef -> TYPE ID ( args_list_or_empty ) compound_instr .

    TYPE            reduce using rule 76 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    PRINT           reduce using rule 76 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    ID              reduce using rule 76 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    IF              reduce using rule 76 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    WHILE           reduce using rule 76 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    REPEAT          reduce using rule 76 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    RETURN          reduce using rule 76 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    BREAK           reduce using rule 76 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    CONTINUE        reduce using rule 76 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    {               reduce using rule 76 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    (               reduce using rule 76 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    INTEGER         reduce using rule 76 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    FLOAT           reduce using rule 76 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    STRING          reduce using rule 76 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    $end            reduce using rule 76 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)


state 149

    (29) choice_instr -> IF ( condition ) instruction ELSE . instruction
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expr_list ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { declarations instructions_opt }
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    PRINT           shift and go to state 15
    ID              shift and go to state 31
    IF              shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 25
    RETURN          shift and go to state 12
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 38
    {               shift and go to state 39
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    return_instr                   shift and go to state 18
    const                          shift and go to state 19
    assignment                     shift and go to state 27
    instruction                    shift and go to state 151
    compound_instr                 shift and go to state 30
    continue_instr                 shift and go to state 21
    labeled_instr                  shift and go to state 28
    print_instr                    shift and go to state 37
    choice_instr                   shift and go to state 13
    repeat_instr                   shift and go to state 17
    bin_expression                 shift and go to state 23
    break_instr                    shift and go to state 33
    while_instr                    shift and go to state 22
    expression                     shift and go to state 40

state 150

    (31) choice_instr -> IF ( error ) instruction ELSE . instruction
    (13) instruction -> . print_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment
    (16) instruction -> . choice_instr
    (17) instruction -> . while_instr
    (18) instruction -> . repeat_instr
    (19) instruction -> . return_instr
    (20) instruction -> . break_instr
    (21) instruction -> . continue_instr
    (22) instruction -> . compound_instr
    (23) instruction -> . expression ;
    (24) print_instr -> . PRINT expr_list ;
    (25) print_instr -> . PRINT error ;
    (26) labeled_instr -> . ID : instruction
    (27) assignment -> . ID = expression ;
    (28) choice_instr -> . IF ( condition ) instruction
    (29) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (30) choice_instr -> . IF ( error ) instruction
    (31) choice_instr -> . IF ( error ) instruction ELSE instruction
    (32) while_instr -> . WHILE ( condition ) instruction
    (33) while_instr -> . WHILE ( error ) instruction
    (34) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (35) return_instr -> . RETURN expression ;
    (37) break_instr -> . BREAK ;
    (36) continue_instr -> . CONTINUE ;
    (38) compound_instr -> . { declarations instructions_opt }
    (43) expression -> . const
    (44) expression -> . ID
    (45) expression -> . bin_expression
    (46) expression -> . ( expression )
    (47) expression -> . ( error )
    (48) expression -> . ID ( expr_list_or_empty )
    (49) expression -> . ID ( error )
    (40) const -> . INTEGER
    (41) const -> . FLOAT
    (42) const -> . STRING
    (50) bin_expression -> . expression + expression
    (51) bin_expression -> . expression - expression
    (52) bin_expression -> . expression * expression
    (53) bin_expression -> . expression / expression
    (54) bin_expression -> . expression % expression
    (55) bin_expression -> . expression | expression
    (56) bin_expression -> . expression & expression
    (57) bin_expression -> . expression ^ expression
    (58) bin_expression -> . expression AND expression
    (59) bin_expression -> . expression OR expression
    (60) bin_expression -> . expression SHL expression
    (61) bin_expression -> . expression SHR expression
    (62) bin_expression -> . expression EQ expression
    (63) bin_expression -> . expression NEQ expression
    (64) bin_expression -> . expression > expression
    (65) bin_expression -> . expression < expression
    (66) bin_expression -> . expression LE expression
    (67) bin_expression -> . expression GE expression

    PRINT           shift and go to state 15
    ID              shift and go to state 31
    IF              shift and go to state 14
    WHILE           shift and go to state 16
    REPEAT          shift and go to state 25
    RETURN          shift and go to state 12
    BREAK           shift and go to state 36
    CONTINUE        shift and go to state 38
    {               shift and go to state 39
    (               shift and go to state 20
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 35
    STRING          shift and go to state 26

    return_instr                   shift and go to state 18
    const                          shift and go to state 19
    assignment                     shift and go to state 27
    instruction                    shift and go to state 152
    compound_instr                 shift and go to state 30
    continue_instr                 shift and go to state 21
    while_instr                    shift and go to state 22
    print_instr                    shift and go to state 37
    choice_instr                   shift and go to state 13
    bin_expression                 shift and go to state 23
    break_instr                    shift and go to state 33
    labeled_instr                  shift and go to state 28
    expression                     shift and go to state 40
    repeat_instr                   shift and go to state 17

state 151

    (29) choice_instr -> IF ( condition ) instruction ELSE instruction .

    PRINT           reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    ID              reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    IF              reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    WHILE           reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    REPEAT          reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    RETURN          reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    BREAK           reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    {               reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    (               reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    INTEGER         reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    FLOAT           reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    STRING          reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    $end            reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    UNTIL           reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    }               reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    ELSE            reduce using rule 29 (choice_instr -> IF ( condition ) instruction ELSE instruction .)


state 152

    (31) choice_instr -> IF ( error ) instruction ELSE instruction .

    PRINT           reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    ID              reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    IF              reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    WHILE           reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    REPEAT          reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    RETURN          reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    BREAK           reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    {               reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    (               reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    INTEGER         reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    FLOAT           reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    STRING          reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    $end            reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    UNTIL           reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    }               reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    ELSE            reduce using rule 31 (choice_instr -> IF ( error ) instruction ELSE instruction .)

